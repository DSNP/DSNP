%
%   Copyright 2011 Adrian Thurston <thurston@complang.org>
%

% vim:expandtab:

\documentclass[letterpaper,11pt,oneside]{article}
\usepackage{comment}

\topmargin -0.20in
\oddsidemargin 0in
\textwidth 6.5in
\textheight 9in

\setlength{\parskip}{0pt}
\setlength{\topsep}{0pt}
\setlength{\partopsep}{0pt}
\setlength{\itemsep}{0pt}

\begin{document}

%
% Title page
%

\thispagestyle{empty}
\begin{center}
{\huge DSNP: Distributed Social Networking Protocol}\\
\vspace*{12pt}
{\Large Protocol Specification}\\
\vspace{12pt}
by\\
\vspace{12pt}
{\large Dr. Adrian D. Thurston}\\
\vspace{22pt}
{\noindent\bf\large Protocol Version: 0.6}\\
\vspace{6pt}
{\noindent\bf\large Document Revision: 11}\\
\vspace{6pt}
{\noindent\bf\large Date: May 19, 2011}
\end{center}

\pagenumbering{roman}

\vspace{1.3in}

\section*{License}

Copyright \copyright\ 2007-2011 Dr. Adrian D. Thurston

\vspace{5pt}

{\bf\it\noindent Permission to use, copy, modify, and/or distribute this
software for any purpose with or without fee is hereby granted, provided that
the above copyright notice and this permission notice appear in all copies.}

\vspace{5pt}

{\bf\it\noindent
THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.}

\vspace{1.5in}

{\noindent\bf\large DISCLAIMER: This document is draft quality. It is steadily
improving in lockstep with the reference implementation.}

\newpage

\tableofcontents

\pagenumbering{arabic}

\newpage

\section{Introduction}

Social networking sites have become an important part of our day-to-day
communication. These sites give us a place to declare our identity, an ability
to establish connections with others, and a suite of efficient broadcast communcation
tools.

This is all well and good, save for the fact that the popular social networks
of today are closed systems that do not allow their users to cross network
boundaries. For social networking to reach its full potential as a
commmunication paradigm, there must be no boundaries between service providers.
Instead, users must be able to establish connections to others regardless of
where they host their profile. 

The rewards of such a system are a freedom to choose providers, competition,
innovation, and dispersion of the data, eliminating the problems associated
with massive repositories of personal information.

The challenges of such a system are security, privacy, and developing feature
rich applications that can compete with the products developed as single
databases.

\subsection{Properties of DSNP}

\begin{enumerate}

\item Identities are URI-based.

\item The system is distributed at the level of identities, as opposed to
collections of identities. Authentication and authorization mechanisms are
based on the credentials of the two users who are interacting. DSNP does not
rely on simply securing the server-server communications with SSL.

\item There is a single sign-on. Once a user has signed into her profile, she
is able to get access to her friend's profiles without submitting any password.

\item DSNP is secure against forgery by non-friends and friends. It is secure
against eavesdropping by non-friends.

\item DSNP allows friendship claims and user activity to be verified by trusted
third parties. False friendships and statements can be claimed easily, but they
can also be discredited easily. This makes it safe for you to evaluate new
friends you don't yet fully trust, without worrying that person will forge
statements by you.

\item Security does not rely on DNS or SSL. If ownership of a domain is lost to
an attacker who is able to secure an SSL cert for the domain, the attacker does
not gain control of the identities on the domain.

\item DSNP allows unfriending. Once a user is unfriended, they no longer have
access to the user's broadcasts, even if they are somehow able to snoop the
broadcast traffic.

\item DSNP allows users to deny messages and trace a leak in the event that a
private statement is shared along with the proof.

\end{enumerate}

\subsection{Security Model}

DSNP leverages RSA public key cryptography for identity, the sharing of secrets
and the declaration of relationships. It can be described as a public-key
cryptosystem for web-based identities. Each identity gets a public/private key
pair. The public portion of the key must be fetched over SSL. By requiring SSL
for public key fetches we give some assurance that the correct public key is
always distributed, without introducing the complexities involved with a
web-of-trust, or the cost of commercial certificates on a per-user basis. It is
a trade off, however, as it is possible for a domain to change hands and for
the new owner to start different certs for the identities inside the domain.

Use of SSL makes sense because it is already needed to protect the HTTP
interface to the system. We simply use the same cert to solve the problem of
securely transmitting public keys.

Since public keys are securely exchanged, direct communication between friends
can be protected in the usual asymmetric manner, where a session key is
encrypted using the peer's public key, then content is encrypted using the
session key.

Since users can be expected to have very large friend lists, it is desirable to
omit the use of SSL when delivering messages. DNSP could permit this, without
explicitly identifying the sender or recipient. Only pre-shared relationship
identifiers are transmitted. This identifier has meaning only to the sender and
recipient. A snooper is able to discover that pairs are repeatedly
communicating, but cannot discover who. This is in contrast with schemes such
as PGP or CMS, where senders and recipients are identified in each
communication.

Messages broadcasted to all friends are handled using a pre-shared broadcast
key. This is akin to a long-running session key just for broadcasts. Using a
pre-shared key means that messages do not need to crafted for each recipient.
The message can be computed by the sender, stored once, then a copy sent to
each recipient. If desired, messages can be handed to a third party and
delivered on behalf of the user, without the third party being privy to the
message. Only the sender/recipient domains and the relationship identifiers
(which are chosen randomly) are revealed to the broker. 

When you send messages to your friends, either directly or by broadcast,
messages are signed with your private key. Your contacts can then use your
public key to verify that you wrote the message, uploaded the photo, commented
on someone else's post, etc. Message signatures can also be given to common
friends for verification. This solves the problem of forgery, which is of
practical concern for individuals with reputations to preserve among their peer
groups, especially as peer groups grow. Of course, one loses deniability when
messages are signed, but if deniability is needed, social networking is
probably the wrong communication medium.

Your list of friends can be treated as private information. It is impossible
for someone to probe your list of friends if you don't want to publish it. The
list must be explicitly granted, even to current friends (see next point for a
minor exception). This makes it possible to partition your relationships into
different groups, such as family, close friends, co-workers, and people you
hardly know but might like to get to know better.

\subsection{Definitions}

\begin{itemize}

\item Content-Manager: Software that a user, and user's connections interact with.
This software provides the 'front' for the user's identity. At a minimum, this
should be a web-based application, though other forms of content-manager are
possible.

\end{itemize}

\section{Packets}

There are ten messages for carrying encryption parameters, encrypted data, and
various other atoms of the protocol. These messages most often carry binary
payloads. They are often encrypted and used in the construction of other
packets. As a general rule, encryption packets do not carry any sender or
recipient information. Senders and recipients are transmitted in the container
message.

The basic element of the encryption packet is the binary string. It is composed
of a 16bit length in network byte order, then the binary data. Many of the
packet components are expected to contain other packets. The length-data idiom
still applies here. The data can be treated as an opaque binary string that is
then reparsed as some other packet.

\vspace{10pt}
\begin{verbatim}
    len16   = octet octet
    bin16   = len16 *octet
\end{verbatim}
\vspace{10pt}

\subsection{Public Key}
\label{public-key-packet}

The public-key packet is used for transmitting a user's public key. The key
contains \verb|n| and \verb|e| BIGNUM components, encoded in big-endian binary
format. 

\vspace{10pt}
\begin{verbatim}
    n           = bin16
    e           = bin16
    public-key  = %x01 n e
\end{verbatim}
\vspace{10pt}

\subsection{Public Key Set}
\label{public-key-set}

The Public Key Set packages up the four public keys at privilege levels 0 to 3.
Privilege level 0 is the most trusted. The public key set is delivered in a
signed packet (Section \ref{signed}), with the signature verifiable by the
privilege 0 key.

\vspace{10pt}
\begin{verbatim}
    priv0           = bin16
    priv1           = bin16
    priv2           = bin16
    priv3           = bin16
    public-key-set  = %x02 priv0 priv1 priv2 priv3
\end{verbatim}
\vspace{10pt}

\subsection{Relid Set}

The Relid Set is used to package up a collection of relationship IDs that are
used to identify one direction of a relationship. The four relids correspond to
the four privilege levels. All four relids identify the same relationship. A
user messages another user at a specific privilege level by choosing the
appropriate relid corresponding to the protection desired.

\vspace{10pt}
\begin{verbatim}
    priv0      = bin16
    priv1      = bin16
    priv2      = bin16
    priv3      = bin16
    relid-set  = %x03 priv0 priv1 priv2 priv3
\end{verbatim}
\vspace{10pt}

\subsection{Relid Set Pair}

The Relid Set Pair packages up two sets of relationship IDs. This packet is
used in the friendship request process. It is useful for storage of the
relationship IDs. Also, it is returned by the requestor and serves two
purposes, to answer to the encryption challenge, and to return the friendship
requestor's relationship IDs.

\vspace{10pt}
\begin{verbatim}
    requested       = len16 relid-set
    returned        = len16 relid-set
    relid-set-pair  = %x04 requested returned
\end{verbatim}
\vspace{10pt}

\subsection{Relid Response}

The relid response is the packet that the friendship requestor returns to the
responder. It contains a request ID and the pair of relid sets. The request ID
is used to identify the friendship request in the accept/deny process. The
relid set pair contains the set of relids generated by the responder and the
set returned by the requestor.

\vspace{10pt}
\begin{verbatim}
    peer-notify-reqid  = bin16
    rr-relid-set-pair  = len16 relid-set-pair
    relid-response     = %x05 peer-notify-reqid rr-relid-set-pair
\end{verbatim}
\vspace{10pt}

\subsection{Private Key}

Private keys are never transmitted, but they must be stored and backed up
(encrypted). This packet type specifies the format of the private key before it
is encapsulated in a protection envelope.

\vspace{10pt}
\begin{verbatim}
    n            = bin16
    e            = bin16
    d            = bin16
    p            = bin16
    q            = bin16
    dmp1         = bin16
    dmq1         = bin16
    iqmp         = bin16
    private-key  = %x06 n e d p q dmp1 dmq1 iqmp
\end{verbatim}
\vspace{10pt}

\subsection{PW Encrypted}

This packet contains data encrypted with the owning user's password. The
password is hashed (SHA1) and used as the RC4 key (note RC4 is temporary).

\vspace{10pt}
\begin{verbatim}
    pw-enc-message  = len16 SYM-ENC( plain-message ) 
    pw-encrypted = %x07 pw-enc-message
\end{verbatim}
\vspace{10pt}

\subsection{Signed}
\label{signed-packet}

This packet contains plaintext data that is accompanied by a signature. Unless
specified otherwise, the signature is acquired by applying RSA-sign to the
plaintext. 

In the BK Signed Encrypted and the Signed Encrypted messages the
signature is acquired by concatenating either the broadcast key or the
recipient's public key with the plaintext then applying RSA-sign to that. The
plain message component excludes the keys.

\vspace{10pt}
\begin{verbatim}
    sig            = bin16
    plain-message  = bin16
    signed         = %x08 sig plain-message
\end{verbatim}
\vspace{10pt}

\subsection{Signed Id}
\label{signed-packet}

\vspace{10pt}
\begin{verbatim}
    signed-id = %x09 iduri %x00 bin16 bin16
\end{verbatim}
\vspace{10pt}

\subsection{Detached Sig}

\vspace{10pt}
\begin{verbatim}
    detached-sig = %x0a bin16
\end{verbatim}
\vspace{10pt}

\subsection{Detached Sig Key}

\vspace{10pt}
\begin{verbatim}
    detached-sig-key = %x0b bin16 bin16
\end{verbatim}
\vspace{10pt}

\subsection{Signed Encrypted}

The signed-encrypted message contains data that is signed with a public RSA
key, and encrypted with a symmetric key that is included in the message and
protected by the RSA public key. It has two components: the RSA-protected key,
and the symmetric-key protected RSA signature and message. The RSA sig and the
message body are encrypted using the symmetric key as a single stream. The
signature is produced by concatenating the public key packet (Section
\ref{public-key-packet} and the message body, then RSA-signing the resulting
block. SHA1 is used as the signing hash. RC4 is used as the stream cipher
(temporary).

\vspace{10pt}
\begin{verbatim}
    protected-key     = len16 PK-ENC( sym-key )

    enc-message       = len16 SYM-ENC( signed )

    signed-encrypted  = %x0c protected-key enc-message
\end{verbatim}
\vspace{10pt}

\subsection{BK Keys}

\vspace{10pt}
\begin{verbatim}
    bk-keys = %x0d bin16 bin16
\end{verbatim}
\vspace{10pt}

\subsection{BK Encrypted}

\vspace{10pt}
\begin{verbatim}
    enc-message       = len16 SYM-ENC( signed )

    bk-encrypted      = %x0e enc-message
\end{verbatim}
\vspace{10pt}


\subsection{BK Signed Encrypted}

The bk-signed-encrypted message contains data that is signed with a public RSA
key and encrypted with a pre-shared symmetric key. The encrypted data block
contains two components: the signature and the message data. Both are encrypted
as a single stream. The signature is produced by concatenating the broadcast
key with the message data, then signing the resulting block. SHA1 is used as
the signing hash. RC4 is used as the stream cipher (temporary).

\vspace{10pt}
\begin{verbatim}
    enc-message          = len16 SYM-ENC( signed ) 

    bk-signed-encrypted  = %x0f enc-message
\end{verbatim}
\vspace{10pt}

\subsection{Broadcast}

\vspace{10pt}
\begin{verbatim}
    publisher       = %x01
    author          = %x02
    subject         = %x03
    body            = %x04
    broadcast-type  = %x10

    iduri           = bin16
    sig             = bin16 

    broadcast =
            broadcast-type
            [ publisher iduri sig ]
            [ author iduri sig ]
            *( subject iduri sig )
            body 
            bin16 
\end{verbatim}
\vspace{10pt}

\subsection{Recipient List}

\vspace{10pt}
\begin{verbatim}
    recipient-list  = 
            %x11 *( relid %x00 iduri %x00 ) %x00
\end{verbatim}
\vspace{10pt}


%
% Section: Protocol
%

\section{Protocol}

DSNP has both text and binary elements. Communcation between DSNPd and content
managers are in a textual format. This covers commands and notifications.
Daemon-daemon communication and exportable packets are in a binary format.

The textual commands and notifications all have the same general structure.
They consist of a command or notificaiton name, a list of arguments, CRLF, and
an optional message body. If there is a message body, the last argument will be
the number of bytes in the message body. Message bodies can be arbitrary data,
and should be parsed separately from the message. A CRLF follows the message
body.

The binary packets and commands use a single byte to indicate the type of
element, followed by any number of arguments. Arguments are generally a
fixed-width atom, a null-terminated string, or binary data in length-body
format.

\subsection{Timeouts}

A DSNP implementation should close connections after a time of inactivity. The
DSNP daemon times out connections after 7 seconds, both when reading and
writing. The user agent times out connections to the daemon after 12 seconds.

\subsection{Modified Base64}

Throughout DSNP a modified Base64 encoding is used for binary data. The
characters \verb|-| and \verb|_| are used in place of \verb|+| and \verb|/| for
the 63rd and 64th characters. This modified encoding is commonly used in
applications where Base64 data must be embedded in URLs. Note that we omit
trailing padding, which is normally specified using the \verb|=| character.

\vspace{10pt}
\begin{verbatim}
    base64-chars  = %x41-5A / %x61-7A / %x30-39 / "-" / "_"

    base64        = 1*( base64-chars )
    
    message-id    = 1*( base64-chars / "+" "." )
\end{verbatim}
\vspace{10pt}

\subsection{Iduri and Site}

\vspace{10pt}
\begin{verbatim}
    dist-name    = base64

    # FIXME: - not ABNF
    path-part    = 1*( graph - "/" )

    rel_path     = *( path_part "/" ) [ path_part ];

    path         = "/" rel_path

    iduri        = "dsnp://" path-part "/" rel_path

    site         = iduri

    key          = base64
\end{verbatim}

\subsection{Passwords}

\vspace{10pt}
\begin{verbatim}
    pass = 1*( ::graph:: )
\end{verbatim}
\vspace{10pt}

\subsection{Connection Negotiation}

The DSNP command is the initial command that must be sent by all clients. In
this command, the client sends the DSNP versions it is willing to talk and the
and the connection authentication method.

The auth method can be either a local connection, or a TLS-secured connection.
Local connections require a secret key, which is typically stored on disk on
the server. Local connections must pass through the loopback network interface
(be bound to 127.0.0.1). Local connections that do not should be rejected.

If it is a TLS-secured connection, the server must supply a valid certificate
that matches the requested hostname. The server responds with OK followed by
the version it has chosen from the list. \verb|"OK" SP version EOL|. This
should be the highest supplied version it supports.

\vspace{10pt}
\begin{verbatim}
    SP           = %x20
    EOL          = [ %x0D ] %x0A

    auth = 
        "local" SP key /
        "start_tls" SP host

    version = '0.6'

    supported-versions = version *( "|" version )

    connection-negotation = 
        "DSNP" SP supported-versions SP auth EOL
\end{verbatim}
\vspace{10pt}

\subsection{Creating Users}

A user name and password is requested. The user's IDURI is assigned. It
consists of the scheme \verb'dsnp://', the site's root name, and the user name
as the final path component. It must end with a slash. Similarly, the user's
IDURL is assigned. This is identical, except the scheme is \verb'https://'.

%
% IDURI: dsnp://www.foo.com/site/gia/ 
% IDURL: https://www.foo.com/site/gia/
%

Four RSA key pairs are created. The keys have privilege levels 3 to 0.
Privilege level 3 is considered the weakest. Privilege level 0 is reserved for
the most significant actions, such as profile moving.

\begin{itemize}
\item Priv 3: Not password protected. For activity that doesn't require the user be logged
in.

\item Priv 2: Password protected, decrypted in memory only while user is logged
in. A sig indicates the user is currently logged in. Used for activity by
logged in user.

\item Priv 1: Password protected. Purged from memory immediately after it is
used. Decrypted on each login. A signed timestamp by this key indicates the
user logged in with her password at that time.

\item Priv 0: Password protected. Purged from memory immediately after use.
Decrypted on demand. A message signed by this key indicates the user submitted
her password to produce the signature. This privilege ring is reserved for
moving and deleting the identity.
\end{itemize}

The public portions of the keys are made available (Section
\ref{public-key-command}). The key must always be fetched using SSL. This
guarantees that a key has been provided by the server hosting the identity and
has not been altered.

\subsubsection{New User}

\vspace{10pt}
\begin{verbatim}
    local-new-user = 
            "NEW_USER" SP
            user SP 
            pass EOL
\end{verbatim}
\vspace{10pt}

The context is a local connection. This command returns \verb|"OK"| followed by
\verb|EOL|.

\subsection{Owner Login}

To login, the user agent submits credentials to the LOGIN command. key that
will be used to verify with the server that the user is logged in when commands
are issued (not yet added to the protocol).

\subsubsection{Login}

The session ID is a string that is used to associate the granted login token
with the session ID of the browser. It is supplied to the user agent when DSNPd
needs to specify to the user agent that the browser's login token has expired.

\vspace{10pt}
\begin{verbatim}
    local-login = 
            "LOGIN" 
            user SP 
            pass SP 
            session-id EOL
\end{verbatim}
\vspace{10pt}

This command is for local connections only. On success, the login commands
returns the owner's URI hash, a login token, and the number of seconds the
token is valid for. The URI hash can be computed independently, but is returned
here for convenience. \verb|"OK" SP hash SP token SP lasts EOL|.

\subsubsection{Public Key}
\label{public-key-command}

The Public Key command is for fetching a user's public key. A public key must
never change. If a peer detects a change, the user must be considered invalid.
The message returned is a signed packet (Section \ref{signed-packet}), that
contains a public key set (Section \ref{public-key-set}). The priv0 key is used
for signing.

\vspace{10pt}
\begin{verbatim}
    public-key = %x32 user %x00
\end{verbatim}
\vspace{10pt}

This command is for TLS connections only. It returns \verb|%x bin16|.

\subsection{Friendship Request}

The purpose of the friendship request is to establish a connection between two
users. A remote user to indicates to a local user that she wishes to establish
a connection. During this exchange, the two sites securely exchange random
identifiers that will be used by the two parties to identify the relationship,
should it proceed.

It is important that the user who is receiving the friend request be assured
that the person controlling the browser is the actual owner of the identity
submitted. To guarantee this, we must send the browser home, where it can
answer to a challenge to decrypt a randomly selected token. The browser then
sends the token back. When the token is sent back a similar challenge is issued
to ensure the person making the friend request indeed has the right identity.

There are two other parts of the DSNP protocol that have this flavour:
cross-site login and remote publishing both issue a challenge and require the
browser to go home, fetch the answer, then return it. In the course of this all
three parties, browser, the browser's server and the friend's server, are
assured they are dealing with who they think they are.

The person requesting friendship is the referred to as the requestor, with
identity requestor-iduri. The person who is receiving the request is the responder, with
identity responder-iduri

\begin{enumerate}
\item The requestor fills in a friend request form at resp-iduri
    \begin{enumerate}
    \item requestor answers a challenge, which can be a CAPTCHA, or 
            personalized question
    \item requestor submits requestor-iduri
    \end{enumerate}

\item The responder's server processes the request:
    \begin{enumerate}
    \item verifies challenge response
    \item fetches the public key for requestor-iduri (using SSL)
    \item randomly generates a set of one-way relationship ids (requested-relid-set)
    \item randomly generates a one-way request id (requested-reqid)
    \item encrypts the relationship ids to requestor and signs it
    \item makes message available to be fetched using requested-reqid to identify it
    \item redirects the requestor's browser home to requestor-iduri, calling the return-relid 
        function with resp-iduri and requested-reqid as arguments
    \end{enumerate}

\item Requestor's server processes the return-relid call:
    \begin{enumerate}
    \item verifies browser is logged in as the owner of requestor-iduri
    \item fetches public key for resp-iduri (using SSL)
    \item fetches encrypted requested-relid-set from resp-iduri using requested-reqid
    \item decrypts and verifies requested-relid-set
    \item randomly generates returned-relid-set
    \item randomly generates returned-reqid
    \item encrypts (requested-relid-set,returned-relid-set) to responder and signs it
    \item makes message available to be fetched using returned-reqid to identify it
    \item redirects the friender back to responder-iduri, where the friend-final function is called
    with requestor-iduri and returned-reqid as arguments.
    \end{enumerate}

\item Responder's processes the friend-final call:
    \begin{enumerate}
    \item fetches encrypted (requested-relid-set,returned-relid-set) from requestor-iduri using returned-reqid
    \item decrypts and verifies message, must contain correct requested-relid-set
    \item stores request for friendee to accept/deny
    \end{enumerate}
\end{enumerate}

There are five commands related to friendship request. The first three are the
commands used by the user agent on behalf of the browser for the three major
steps. The last two are commands used by DSNPd to fetch the encrypted the
relids.

\subsubsection{Relid Request}

The relid request is issued by the responder's server on behalf of the
requestor. The server generates a relationship ID and makes it available for
the requestor's server to fetch. It then redirects the user back home where the
request can be processed.

\vspace{10pt}
\begin{verbatim}
    relid-request =
            "RELID_REQUEST" SP
            user SP 
            iduri EOL

    returns: OK reqid EOL
    context: local connection
\end{verbatim}
\vspace{10pt}


\subsubsection{Relid Response}

The relid response is executed by the requestor. The requestor must be logged
in for this command to run. The requestor's server fetches the request from the
responder's server, decrypts and verifies it. It then generates a response and
makes it available for the responder's server to fetch in the final step.

\vspace{10pt}
\begin{verbatim}
    relid-response = 
            "RELID_RESPONSE" SP
            login_token SP
            reqid SP
            iduri EOL

    returns: OK reqid EOL
    context: local connection
\end{verbatim}
\vspace{10pt}


\subsubsection{Friend Final}

The final step in the friend request protocol is for the responder's server to
verify the response, which includes a copy of the request it generated in the
first step. If the response validates, a friend request is stored for the
responder user to accept or deny.

\vspace{10pt}
\begin{verbatim}
    friend-final =
            "FRIEND_FINAL" SP
            user SP
            reqid SP
            iduri EOL

    returns: OK EOL
    context: local connection
\end{verbatim}
\vspace{10pt}


\subsubsection{Fetch Requested Relid}

\vspace{10pt}
\begin{verbatim}
    fetch-requested-relid = 
            %x33
            reqid %x00

    returns: OK message EOL
    context: TLS connection
\end{verbatim}
\vspace{10pt}


\subsubsection{Fetch Response Relid}

\vspace{10pt}
\begin{verbatim}
    fetch-response-relid =
            %x34
            reqid %x00

    returns: OK message EOL
    context: TLS connection
\end{verbatim}


\subsection{Friendship Accept and Deny}

The next time the friendee logs in they are presented with the friendship
request. They can either accept or deny the request. 

The acceptor sends accept notification with both relids. They are sent back
indicating that the friendship was registered on the other end. The acceptor
then registers the friendship and sends a registered message. It can can now
send broadcast key and broadcast tree insertion messages. The other end can
send these messages after it receives the registered message.

\subsubsection{Accept Friend}

Accept friend is issued by the responder. The particular friend request is
identified by reqid, which is the request ID originally allocated by the
responder in the relid request command. The responder must be logged in.

\vspace{10pt}
\begin{verbatim}
    accept-friend =
            "ACCEPT_FRIEND" SP
            login_token SP
            reqid EOL

    returns: OK EOL
    context: local connection
\end{verbatim}
\vspace{10pt}


\subsubsection{Notify Accept, Registered}

During the friend accept exchange, these messages arrive as the payload to
standard messages. They are identified as prefriend messages by the state of
the relationship. Notify accept is used to indicate to the requestor that the
receiver intends to accept the friendship request. If the requestor still
considers the request valid, it indicates so and registers the friendship. The
friendee then registers the friendship and sends the REGISTERED message to
indicate that the process is now complete, and friend-friend messages can be
sent. This is how the friender knows it is safe to begin sending messages and
otherwise broadcast information.

\vspace{10pt}
\begin{verbatim}
    notify-accept = 
            %x01 
            peer-notify-reqid

    returns: OK EOL
    context: prefriend message
\end{verbatim}
\vspace{10pt}


\vspace{10pt}
\begin{verbatim}
    registered = 
            %x02 
            peer-notify-reqid 
            friend-claim-sig-key

    returns: OK EOL
    context: prefriend message
\end{verbatim}


\subsection{Login as a Friend}

Once a user is logged in to her page, she is able to login to her friend's
pages without submitting any credentials. The friend's site requests that she
go to her own page to fetch the answer to a crypto challenge that is posed
directly to her identity. At her own site it is verified that she is is the
owner, and the login token is returned to the friend's site. Note that this
pattern is identical to friendship request, and is repeated throughout DSNP.

The user wishing to login to the friend's site is referred to as the requestor,
and she is identified as requestor-iduri. The relid she uses to identify the relationship
we call the QURI-RELID, and will be the one she was given during the friendship
request process. The friend who's page is being logged into will be called the
responder, and her identity is responder-iduri.

\begin{enumerate}
\item The requestor visits responder-iduri/login-as-friend
    \begin{enumerate}
    \item submits as the only argument a hash of requestor-iduri
    \end{enumerate}

\item The responder's server processes the request
    \begin{enumerate}
    \item verifies that hash(requestor-iduri) is a friend
    \item randomly generates a reqid and login token
    \item encrypts the token to the user and signs it
    \item makes it available to be fetched with reqid as identifier
    \item redirects user to requestor-iduri/return-token with hash(requestor-iduri) and reqid as
            arguments
    \end{enumerate}

\item The requestor's server verifies the browser is the identity owner
    \begin{enumerate}
    \item checks that hash(responder-iduri) is a friend
    \item if browser is not logged in, fails the process
            (sending the user to a login page encourages phishing)
    \item fetches the token using from responder-iduri using reqid to identify it
    \item decrypts and verifies the token
    \item redirects the browser to responder-iduri/submit-ftoken with requestor-iduri 
    and the token as arguments
    \end{enumerate}

\item Friend login final
    \begin{enumerate}
    \item verifies that token is valid for requestor-iduri.
    \item grants friend credentials to the browser for the session.
    \end{enumerate}
\end{enumerate}

There are four commands related to friend login. The first three are used by
the content-manager on behalf of the user in the primary challenge-response
scheme. The fourth is used by the friend logging in to fetch the encrypted
challenge.

\subsubsection{Ftoken Request}

\vspace{10pt}
\begin{verbatim}
    ftoken-request = 
            "FTOKEN_REQUEST" SP 
            user SP 
            hash EOL 

    returns: OK iduri hash reqid EOL
    context: local connection
\end{verbatim}
\vspace{10pt}


\subsubsection{Ftoken Response}

The Ftoken Response command is executed by the requestor's user agent. It is
responsible for supplying the proof that the browser owns the identity that is
logging it. This command requires users be logged in.

\vspace{10pt}
\begin{verbatim}
    ftoken-response = 
            "FTOKEN_RESPONSE" SP 
            login-token SP 
            hash SP 
            reqid EOL 

    returns: OK iduri token EOL
    context: local connection
\end{verbatim}
\vspace{10pt}


\subsubsection{Submit Ftoken}

The session ID is a string that the user agent submits to identify the browser
session that the login is for. This session id may be used later by DSNPd to
invalidate the login.

\vspace{10pt}
\begin{verbatim}
    submit-ftoken = 
            "SUBMIT_FTOKEN" SP 
            token SP 
            session-id EOL 

    returns: OK iduri hash lasts EOL
    context: local connection
\end{verbatim}
\vspace{10pt}


\subsubsection{Fetch Ftoken}

\vspace{10pt}
\begin{verbatim}
    fetch-ftoken = 
            %x35
            reqid %x00

    returns: OK message EOL
    context: TLS connection
\end{verbatim}
    
\subsection{Messages to Friends}

Sending friend-friend messages that are encrypted to the recipient and signed
by the sender. 

\subsubsection{Submit Message}

\vspace{10pt}
\begin{verbatim}
    submit-message = 
            "SUBMIT_MESSAGE" SP 
            login-token SP
            iduri SP 
            length EOL message EOL

    returns: OK EOL
    context: local connection
\end{verbatim}
\vspace{10pt}


\subsubsection{Message}

The message command is used to deliver prefriend messages and friend messages.
The type of message accepted is determined by the state of the friendship
request. The privilege level of the message is determined by the privilege
level relationship ID used to identify the message.

\vspace{10pt}
\begin{verbatim}
    message =
            %x36 
            relid %x00
            bin16 

    returns: message dependent (see below)
    context: TLS connection
\end{verbatim}


\subsubsection{Fof Message}

\vspace{10pt}
\begin{verbatim}
    fof-message =
            %x37 
            relid %x00 
            bin16

    returns: message dependent (see below)
    context: TLS connection
\end{verbatim}


\subsection{Broadcasting to a Group}

As previously mentioned, DSNP uses a broadcast key for the sending of messages
to groups. The key has an ID and a generation. The ID is a base64 encoded
random string assigned by the owner and used by the recipients to identify the
group within the sender's collection of groups.

\subsubsection{Submit Broadcast}

\vspace{10pt}
\begin{verbatim}
    submit-broadcast = 
            "SUBMIT_BROADCAST" SP 
            login-token SP 
            length EOL message EOL

    returns: OK EOL
    context: local connection
\end{verbatim}
\vspace{10pt}


\subsubsection{Broadcast Key}

\vspace{10pt}
\begin{verbatim}
    broadcast-key = 
            %x01 
            dist-name %x00 
            generation64 
            bin64

    returns: OK EOL
    context: user-user message
\end{verbatim}
\vspace{10pt}


\subsubsection{Broadcast Recipient}

\vspace{10pt}
\begin{verbatim}
    broadcast-recipient = 
            %x38
            relid %x00

    returns: OK EOL
    context: TLS connection
\end{verbatim}
\vspace{10pt}


\subsubsection{Broadcast}

\vspace{10pt}
\begin{verbatim}
    broadcast = 
            %x39 
            dist-name %x00
            generation64
            bin16

    returns: message dependent
    context: TLS connection
\end{verbatim}
\vspace{10pt}

\subsection{Remote Broadcasting}

Remote broadcasting (or remote publishing) covers activity that a user makes on
a friend's site, such as commenting on a photo or, writing a public message on
a user's message board. This activity has to be authorized by both the author
of the message and the subject. It must be encrypted and signed by both parties
to prove to the message was not forged, and to ensure that only common friends
are able to view such messages. The encryption requirement may be relaxed to
allow others outside of the common friend group to view messages.

\subsubsection{Remote Broadcast Request}

\vspace{10pt}
\begin{verbatim}
    remote-broadcast-request = 
            "REMOTE_BROADCAST_REQUEST" SP
            flogin-token SP
            length EOL message EOL

    returns: OK reqid EOL
    context: local connection
\end{verbatim}
\vspace{10pt}


\subsubsection{Remote Broadcast Response}

\vspace{10pt}
\begin{verbatim}
    remote-broadcast-response =
            "REMOTE_BROADCAST_RESPONSE" SP
            login-token SP
            reqid EOL 

    returns: OK reqid EOL
    context: local connection 
\end{verbatim}
\vspace{10pt}


\subsubsection{Remote Broadcast Final}

\vspace{10pt}
\begin{verbatim}
    remote-broadcast-final =
            "REMOTE_BROADCAST_FINAL" SP 
            flogin-token SP 
            reqid EOL 

    returns: OK EOL
    context: local connection
\end{verbatim}
\vspace{10pt}


\subsubsection{Encrypt Remote Broadcast Author}

\vspace{10pt}
\begin{verbatim}
    encrypt-remote-broadcast-author = 
            %x02 
            flogin-token %x00 
            dist-name %x00 
            generation64 
            recipient-list
            bin16

    returns: OK reqid EOL
    context: user-user message
\end{verbatim}
\vspace{10pt}


\subsubsection{Encrypt Remote Broadcast Subject}

\vspace{10pt}
\begin{verbatim}
    encrypt-remote-broadcast-subject = 
            %x03 
            hash %x00 
            dist-name %x00 
            generation64 
            recipient-list 
            bin16 

    returns: OK message EOL
    context: user-user message
\end{verbatim}
\vspace{10pt}


\subsubsection{Repub Remote Broadcast Publisher}

\vspace{10pt}
\begin{verbatim}
    repub-remote-broadcast-publisher = 
            %x04 
            message-id %x00 
            dist-name %x00 
            generation64

    returns OK reqid EOL
    context: user-user message
\end{verbatim}
\vspace{10pt}


\subsubsection{Repub Remote Broadcast Author}

\vspace{10pt}
\begin{verbatim}
    repub-remote-broadcast-author = 
            %x05 
            message-id %x00 
            dist-name %x00 
            generation64

    returns OK reqid EOL
    context: user-user message
\end{verbatim}
\vspace{10pt}


\subsubsection{Repub Remote Broadcast Subject}

\vspace{10pt}
\begin{verbatim}
    repub-remote-broadcast-subject = 
            %x06
            message-id %x00
            dist-name %x00
            generation64

    returns OK reqid EOL
    context: user-user message
\end{verbatim}
\vspace{10pt}


\subsubsection{Return Remote Broadcast Author}

\vspace{10pt}
\begin{verbatim}
    return-remote-broadcast-author =
            %x07
            reqid %x00
            bin16

    returns OK reqid EOL
    context: user-user message
\end{verbatim}
\vspace{10pt}


\subsubsection{Return Remote Broadcast Subject}

\vspace{10pt}
\begin{verbatim}
    return-remote-broadcast-subject =
            %x08
            reqid %x00
            bin16

    returns OK reqid EOL
    context: user-user message
\end{verbatim}
\vspace{10pt}


\subsubsection{Broadcast Success Author}

\vspace{10pt}
\begin{verbatim}
    broadcast-success-author =
            %x09
            message-id %x00

    returns OK reqid EOL
    context: user-user message
\end{verbatim}
\vspace{10pt}


\subsubsection{Broadcast Success Subject}

\vspace{10pt}
\begin{verbatim}
    broadcast-success-subject =
            %x0a
            message-id %x00

    returns OK reqid EOL
    context: user-user message
\end{verbatim}
\vspace{10pt}


\subsubsection{Remote Broadcast Key}

\vspace{10pt}
\begin{verbatim}
    rb-broadcast-key =
            %x01
            hash 0 
\end{verbatim}
\vspace{10pt}

\section{Notifications}

The DSNP daemon defers to the content-manager software for tasks that are not
associated with identity, authentication, authorization, encryption, etc. This
includes content that arrives from friends, and various notifications that
result in user experience. Various components require synchronization.

\subsection{Notification Broadcast}

\vspace{10pt}
\begin{verbatim}
    broadcast =
            "BROADCAST" SP
            user SP 
            broadcaster SP 
            length EOL body EOL
\end{verbatim}
\vspace{10pt}

\subsection{Notification Message}

\vspace{10pt}
\begin{verbatim}
    message = 
            "MESSAGE" SP
            user SP 
            sender SP 
            length EOL body EOL
\end{verbatim}
\vspace{10pt}

\subsection{Notification Logout}

The logout notification is used by the daemon to indicate to the user agent
that a login session is no longer valid. This should invalidate any cookies
that have been handed out to user. The session ID can be any string of
characters that the user agent wishes to use. It is limited to 48 characters.

\vspace{10pt}
\begin{verbatim}
    logout = 
            "LOGOUT" SP
            session-id EOL
\end{verbatim}
\vspace{10pt}

\subsection{Notification New User}

Indicates that user creation succeeded. The user agent should register the user
in its database.

\vspace{10pt}
\begin{verbatim}
    new-user =
            "NEW_USER" SP
            user EOL
\end{verbatim}
\vspace{10pt}

\subsection{Friend Request Received}

Notification for the responder to the friend request that a new request has
arrived.

\vspace{10pt}
\begin{verbatim}
    friend-request-received =
            "FRIEND_REQUEST_RECEIVED" SP
            user SP
            iduri SP
            hash SP
            accept-reqid EOL
\end{verbatim}
\vspace{10pt}

\subsection{Friend Request Sent}

Notification for the requestor of the relationship that a new request was
successfully sent.

\vspace{10pt}
\begin{verbatim}
    friend-request-sent =
            "FRIEND_REQUEST_SENT" SP
            user SP
            iduri SP
            hash SP
            user-notify-reqid EOL
\end{verbatim}
\vspace{10pt}

\subsection{Friend Request Accepted}

Notification for the responder to the friend request that acceptance succeeded.

\vspace{10pt}
\begin{verbatim}
    friend-request-accepted =
            "FRIEND_REQUEST_ACCEPTED" SP
            user SP
            iduri SP
            accept-reqid EOL
\end{verbatim}
\vspace{10pt}

\subsection{Sent Friend Request Accepted}

Notification for the requestor of the relationship that the request was
accepted.

\vspace{10pt}
\begin{verbatim}
    sent-friend-request-accepted =
            "SENT_FRIEND_REQUEST_ACCEPTED"
            user SP
            iduri SP
            user-notify-reqid EOL
\end{verbatim}
\vspace{10pt}

\section{User Messages}

User messages are submitted by the user agent to DSNPd, encrypted, distributed
over the network, decrypted, then handed to the receiving user agent for
storage and display. This particular section of DSNP is likely to change, as
better message formats become apparent. For the time being, we use an
rfc822-like message format. There are just four types.

\begin{verbatim}
publisher-iduri      = "Publisher-Iduri" COLON SP iduri CRLF

author-iduri         = "Author-Iduri" COLON SP iduri CRLF

subject-iduri        = "Subject-Iduri" COLON SP iduri CRLF

message-id           = "Message-Id" COLON SP message-id CRLF

type                 = "Type" COLON SP (
                           "broadcast" /
                           "board-post" /
                           "name-change" /
                           "photo-upload" /
                           "tag"
                        ) CRLF

content-type         = "Content-Type" COLON SP
                           ( "text/plain" / "image/jpg" )

date                 = "Date" COLON SP
                           4digit "-" 2digit "-" 2digit " " 
                           2digit ":" 2digit ":" 2digit CRLF

remote-resource      = "Remote-Resource" COLON SP path CRLF

remote-presentation  = "Remote-Presentation" COLON SP path CRLF
\end{verbatim}

\subsection{Broadcast}

Broadcast message type is used for so-called status updates.

\vspace{10pt}
\begin{verbatim}
Publisher-Iduri: publisher-iduri
Message-Id: message-id
Content-Type: text/plain
Type: broadcast
Date: YYYY-MM-DD HH:MM:SS

CONTENT
\end{verbatim}
\vspace{10pt}

\subsection{Board Post}

Board post is used for messages that are to be shared with the sender and
recipient's friends. The board post is akin to a "wall" message.

\vspace{10pt}
\begin{verbatim}
Author-Iduri: author-iduri
Publisher-Iduri: publisher-iduri
Message-Id: message-id
Type: board-post
Content-Type: text/plain
Date: YYYY-MM-DD HH:MM:SS

CONTENT
\end{verbatim}
\vspace{10pt}

\subsection{Name Change}

Name change is used to transmit a user's new name.

\vspace{10pt}
\begin{verbatim}
Publisher-Iduri: publisher-iduri
Message-Id: message-id
Type: name-change
Content-Type: text/plain
Date: YYYY-MM-DD HH:MM:SS

CONTENT
\end{verbatim}
\vspace{10pt}

\subsection{Photo Upload}

Photo upload is use to notifiy friend's about a photo that has been uploaded.
Resource-Id is an identifier describing the uploader's image.

\vspace{10pt}
\begin{verbatim}
Publisher-Iduri: publisher-iduri
Type: photo-upload
Message-Id: message-id
Type: name-change
Content-Type: image/jpg
Remote-Resource: /full/path/to/resource
Remote-Presentation: /full/path/to/presentation/page
Date: YYYY-MM-DD HH:MM:SS

CONTENT
\end{verbatim}
\vspace{10pt}

\subsection{Photo Tag}

Photo upload is use to notifiy friend's about a photo that has been uploaded.
Resource-Id is an identifier describing the uploader's image.

\vspace{10pt}
\begin{verbatim}
Author-Iduri: author-iduri
Publisher-Iduri: publisher-iduri
Subject-Iduri: subject-iduri
Type: photo-tag
Message-Id: message-id
Type: name-change
Content-Type: image/jpg
Remote-Resource: /full/path/to/resource
Remote-Presentation: /full//path/to/presentation/page
Date: YYYY-MM-DD HH:MM:SS

CONTENT
\end{verbatim}
\vspace{10pt}

\end{document}
