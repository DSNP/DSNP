%
%   Copyright 2011 Adrian Thurston <thurston@complang.org>
%

% vim:expandtab:

\documentclass[letterpaper,11pt,oneside]{article}
\usepackage{comment}

\topmargin -0.20in
\oddsidemargin 0in
\textwidth 6.5in
\textheight 9in

\setlength{\parskip}{0pt}
\setlength{\topsep}{0pt}
\setlength{\partopsep}{0pt}
\setlength{\itemsep}{0pt}

\begin{document}

%
% Title page
%

\thispagestyle{empty}
\begin{center}
{\huge DSNP: Distributed Social Networking Protocol}\\
\vspace*{12pt}
{\Large Protocol Specification}\\
\vspace{12pt}
by\\
\vspace{12pt}
{\large Dr. Adrian D. Thurston}\\
\vspace{22pt}
{\noindent\bf\large Protocol Version: 0.2}\\
\vspace{6pt}
{\noindent\bf\large Document Revision: 5}\\
\vspace{6pt}
{\noindent\bf\large Date: January 28, 2011}
\end{center}

\pagenumbering{roman}

\vspace{1.3in}

\section*{License}

Copyright \copyright\ 2007-2011 Dr. Adrian D. Thurston

\vspace{5pt}

{\bf\it\noindent Permission to use, copy, modify, and/or distribute this
software for any purpose with or without fee is hereby granted, provided that
the above copyright notice and this permission notice appear in all copies.}

\vspace{5pt}

{\bf\it\noindent
THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.}

\vspace{1.5in}

{\noindent\bf\large DISCLAIMER: This document is draft quality. As of early
2011, it is steadily improving in lockstep with the reference implementation,
Choice Social.}

\newpage

\tableofcontents

%
% Chapter 1
%


% Topics:
% RSA Keys allocated to each identity
%
% Broadcast Keys
%
% Properties.
%  Forgery
%  Privacy
%
% Protocol
%  Friendship Initialization

\pagenumbering{arabic}

\section{Introduction}

% DSNP uses a similar pattern. A submits its URI to B. B encrypt-signs a
% challenge to A. The browser visits A to prove it initiated the
% exchange. A encrypt-signs a response to B. Then friendship exists.
%
% Keys are indeed cheap. I was thinking of using two keys actually. One
% would be stored in plaintext on the server, the other encrypted using
% the user's password. The encrypted key would be used to communicate
% any major changes concerning the user's identity. It would be a higher
% privilege key for certain operations. I haven't hashed it out yet
% though.
%
% In DSNP I introduced a symmetric broadcast key. It is distributed to
% each friend ahead of time using each friend's public keys. It is
% versioned as well. It must change when unfriending happens.
% 
% Status updates (and other activity) can then be encrypted using using
% the broadcast key (and signed). This can be done once, then the same
% message delivered to all friends. I took this approach because I
% wanted to reduce the computation required for a single status
% update/post/etc. Some quick tests showed that encryption to 2000
% friends (extreme) when 2000 public keys were used was very costly.
% Multiply this by however many users are on a mulituser system and I
% got worried.

DSNP is a protocol for distributed social networking. The goal of this project
is to allow you to host your profile with a provider of your choice, or host
your profile yourself, without the choice impacting who you are able to invite
as connections. Communication between you and the people you trust is private
and safe from forgery.

DSNP aims to cover any use case that can be described as first creating a
profile for yourself, establishing connections to people you know, then
broadcasting private information to these people. The information that we share
are the artifacts of our lives. No single provider should host such information
everyone.

\subsection{Properties of DSNP}

\begin{enumerate}

\item Identities are URI-based.

\item The system is distributed at the level of identities, as opposed to
collections of identities. Authentication and authorization mechanisms are
based on the credentials of the two users who are interacting. DSNP does not
rely on simply securing the server-server communications with SSL.

\item There is a single sign-on. Once a user has signed into her profile, she
is able to get access to her friend's profiles without submitting any password.

\item DSNP is secure against forgery by non-friends and friends. It is secure
against eavesdropping by non-friends.

\item DSNP allows friendship claims and user activity to be verified by trusted
third parties. False friendships and statements can be claimed easily, but they
can also be discredited easily. This makes it safe for you to evaluate new
friends you don't yet fully trust, without worrying that person will forge
statements by you.

\item Security does not rely on DNS or SSL. If ownership of a domain is lost to
an attacker who is able to secure an SSL cert for the domain, the attacker does
not gain control of the identities on the domain.

\item DSNP allows unfriending. Once a user is unfriended, they no longer have
access to the user's broadcasts, even if they are somehow able to snoop the
broadcast traffic.

\end{enumerate}

% Wishlist.
%\begin{enumerate}
%\item Identities can be exported and migrated to another provider.
%\end{enumerate}

\subsection{Security Model}

DSNP leverages RSA public key cryptography for identity, the sharing of secrets
and the declaration of relationships. It can be described as a public-key
cryptosystem for web-based identities. Each identity gets a public/private key
pair. The public portion of the key must be fetched over SSL. By requiring SSL
for public key fetches we give some assurance that the correct public key is
always distributed, without introducing the complexites involved with a
web-of-trust, or the cost of commercial certificates on a per-user basis. It is
a trade off, however, as it is possible for a domain to change hands and for
the new owner to start different certs for the identities inside the domain.

Use of SSL makes sense because it is already needed to protect the HTTP
interface to the system. We simply use the same cert to solve the problem of
securely transmitting public keys.

Since public keys are securely exchanged, direct communication between friends
can be protected in the usual asymmetric manner, where a session key is
encrypted using the peer's public key, then content is encrypted using the
session key.

Since users can be expected to have very large friend lists, it is desirable to
omit the use of SSL when delivering messages. DNSP could permit this, without
explicitly identifying the sender or recipient. Only pre-shared relationship
identifiers are transmitted. This identifier has meaning only to the sender and
recipient. A snooper is able to discover that pairs are repeatedly
communicating, but cannot discover who. This is in contrast with schemes such
as PGP or CMS, where senders and recipients are identified in each
communication.

Messages broadcasted to all friends are handled using a pre-shared broadcast
key. This is akin to a long-running session key just for broadcasts. Using a
pre-shared key means that messages do not need to crafted for each recipient.
The message can be computed by the sender, stored once, then a copy sent to
each recipient. If desired, messages can be handed to a third party and
delivered on behalf of the user, without the third party being privy to the
message. Only the sender/recipient domains and the relationship identifiers
(which are chosen randomly) are revealed to the broker. 

When you send messages to your friends, either directly or by broadcast,
messages are signed with your private key. Your contacts can then use your
public key to verify that you wrote the message, uploaded the photo, commented
on someone else's post, etc. Message signatures can also be given to common
friends for verification. This solves the problem of forgery, which is of
practical concern for individuals with reputations to preserve among their peer
groups, especially as peer groups grow. Of course, one loses deniability when
messages are signed, but if deniability is needed, social networking is
probably the wrong communication medium.

Your list of friends can be treated as private information. It is impossible
for someone to probe your list of friends if you don't want to publish it. The
list must be explictly granted, even to current friends (see next point for a
minor exception). This makes it possible to partition your relationships into
different groups, such as family, close friends, co-workers, and people you
hardly know but might like to get to know better.

\subsection{Definitions}

\begin{itemize}

\item User-agent: Software that a user, and user's connections interact with.
This software provides the 'front' for the user's identity. At a minimium, this
should be a web-based application, though other forms of user-agent are
possible.

\end{itemize}

\section{Basics}

In the sections that follow, standard regular expression syntax is used to
describe the terminal elements of the grammar. A less formal notation is used
for commands and other protocol elements that are constructed with the base
elements. In the less formal sections, white space simply used in places where
it is required.

All commands, messages, and encryption packets have the same general structure.
They consist of a command or message name, a list of arguments, CRLF, and an
optional message body. If there is a message body, the last argument will be
the number of bytes in the message body. Message bodies can be arbitrary data,
and should be parsed separately from the message. A CRLF follows the message
body.

\subsection{Modified Base64}

Throughout DSNP a modified Base64 encoding is used for binary data. The
characters \verb|-| and \verb|_| are used in place of \verb|+| and \verb|/| for
the 63rd and 64th characters. This modified encoding is commonly used in
applications where Base64 data must be embedded in URLs. Note that we omit
trailing padding, which is normally specified using the \verb|=| character.

\vspace{10pt}
\begin{verbatim}
    base64: /[A-Za-z0-9\-_]+/
\end{verbatim}
\vspace{10pt}

\subsection{User Names}

Valid characters in user names include letters, numbers, dot, dash and
underscore. Uppercase letters can be used to specify, but they are stored and
displayed in all lowercase to ensure that URIs are given as lowercase.

\vspace{10pt}
\begin{verbatim}
    user: /[a-zA-Z0-9][a-zA-Z0-9\.\-_]*/
\end{verbatim}
\vspace{10pt}

\subsection{Passwords}

Passwords can be any comprised any graphical characters.

\vspace{10pt}
\begin{verbatim}
    pass: [::graph::]+
\end{verbatim}
\vspace{10pt}

\subsection{Timeouts}

A DSNP inmplementation should time out connections. The DSNP daemon times out
connections after 7 seconds, both when reading and writing. The user agent
times out connections to the daemon after 12 seconds.

\section{Encryption Parameters and Data}

There are three messages for carrying encryption parameters and encrypted data.
Encryption data does not carry any sender or recipeint information. Senders and
recipients are transmitted in the container message. Message bodies are binary.

\subsection{Public Key}

\vspace{10pt}
\begin{verbatim}
    public_key pub1nLen length EOL key_data EOL
\end{verbatim}
\vspace{10pt}

The public-key packet is used for transmitting a user's public key. The key
contains \verb|n| and \verb|e| BIGNUM components, encoded in big-endian binary
format. The \verb|key_data| consists of these two binary components
concatenated together. The length of the second component can be computed by
subtracting the length of the first from the overall message body length.

\subsection{Signed Encrypted}

The signed-encrypted message contains data that is signed with a public RSA key
and encrypted with a symmetric key that is included in the message and
protected by the RSA public key. It has three components: the RSA-protected
key, the RSA signature, and the symmetric-key protected message. The parameter
list contains the lengths of the first two comonents. The third length is
computed from the overall length. The RSA sig and the message body are
encrypted using the symmetric key as a single stream. The signature is produced
by concatenating the public key (n and e components) and the message body, then
RSA-signing the resulting block. SHA1 is used as the signing hash. RC4 is used
as the stream cipher (temporary).

\vspace{10pt}
\begin{verbatim}
signed_encrypted protKeyLen sigLen length EOL enc_data EOL
\end{verbatim}
\vspace{10pt}

\subsection{BK Signed Encrypted}

The bk-signed-encrypted message contains data that is signed with a public RSA
key and encrypted with a pre-shared symmetric key. The encrypted data block
contains two components: the signature and the message data. Both are encrypted
as a single stream. Only the first component length is included. The second is
computed from the overall length. The signature is produced by concatenating
the broadcast key with the message data, then signing the resulting block. SHA1
is used as the signing hash. RC4 is used as the stream cipher (temporary).

\vspace{10pt}
\begin{verbatim}
bk_signed_encrypted sigLen length EOL enc_data EOL
\end{verbatim}
\vspace{10pt}

\section{Protocol}

\subsection{Common Elements}

\vspace{10pt}
\begin{verbatim}
    dist_name = base64;

    date = (
        digit{4} '-' digit{2} '-' digit{2} ' ' 
        digit{2} ':' digit{2} ':' digit{2} 
    )

    path_part = ( graph - '/' )+;

    identity = 
        ( 'https://' path_part '/' ( path_part '/' )* );

    site = identity;

    number = [0-9]+           


    version = '0.1'
    supported_versions =  version ( '|' version )*;
    key = base64;

    EOL = '\r'? '\n';
\end{verbatim}

\subsection{Connection Negotiation}

The DSNP command is the initial command that must be sent by all clients. In
this command, the client sends the DSNP versions it is willing to talk, the
site it wishes to communicate with, and the connection authorization method.

The auth method can be either a local connection, or a TLS-secured connection.
Local connections require a secret key, which is typically stored on disk on
the server. Local connections must pass through the loopback network interface
(be bound to 127.0.0.1). Local connections that do not should be rejected.

If it is a TLS-secured connection, the server must supply a valid certificate
that matches the hostname of the site. The server responds with OK followed by
the version it has chosen from the list. This should be the highest supplied
version it supports.

\vspace{10pt}
\begin{verbatim}
    auth: /local/ key
    auth: /start_tls/

    DSNP supported_versions site auth EOL

    returns: OK version EOL
    context: TCP
\end{verbatim}

\subsection{Creating Users}

\vspace{10pt}
A user name and password is requested. These credentials will be used by the
user to login as the owner of the identity.

A URI consisting of the site root name, followed by the user name as the last
component is assigned. This is an internet facing web address that the user has
control of. It represents their identity.

An RSA key pair is created. The key has no password. (In future versions of the
protocol we may generate two key pairs, one with no password,  another with a
password. The encrypted key will be required at times when the user is logged
in.

The public portion of the key is made available. The key must always be fetched
using SSL. This guarantees that a key has been provided by the server hosting
the identity and has not been altered.

\subsubsection{New User}

\vspace{10pt}
\begin{verbatim}
    NEW_USER user pass EOL

    returns: OK EOL
    context: local connection
\end{verbatim}

\subsection{Owner Login}

To login, the user agent submits credentials to the LOGIN command. key that
will be used to verify with the server that the user is logged in when commands
are issued (not yet added to the protocol).

\subsubsection{Login}

The session ID is a string that is used to associate the granted login token
with the session ID of the browser. It is supplied to the user agent when DSNPd
needs to specify to the user agent that the browser's login token has expired.

\vspace{10pt}
\begin{verbatim}
    LOGIN user pass session_id EOL

    returns: OK hash token lasts EOL
    context: TLS connection
\end{verbatim}
\vspace{10pt}

On success, the login commands returns the owner's URI hash, a login token, and
the number of seconds the token is valid for. The URI hash can be computed
independently, but is returned here for convenience.

Note that as of version 0.2 of DSNP, the token is not yet made use of. It
should be!

\subsection{Friendship Request}

The friendship request has two purposes. The primary purpose is the stated, for
a remote user to indicate to a local user that she wishes to establish a
connection. The secondary purpose is to securely exchange random identifiers
that will be used by the two parties to identify the relationship, should it
proceed.

It is important that the user who is recieving the friend request be assured
that the person controlling the browser is the actual owner of the identity
submitted. To guarantee this, we must send the browser home, where it can
answer to a challenge to decrypt a randomly selected token, then send the token
back. When the token is sent back a similar challenge is issued to ensure the
person making the friend request indeed has the right identity.

There are two other parts of the DSNP protocol that have this flavour:
cross-site login and remote publishing. Indeed it is a recurring pattern to
send the browser home so the that all three parties (browser, the browser's
server and the friend's server) are assured they are dealing with who they
think they are.

The person requesting friendship is the referred to as the requestor, with
identity QURI. The person who is receiving the request is the responder, with
identity SURI

\begin{enumerate}
\item The requestor fills in a friend request form at SURI
    \begin{enumerate}
    \item requestor answers a challenge, which can be a CAPTCHA, or 
            personalized question
    \item requestor submits QURI
    \end{enumerate}

\item Responder's server processes the request:
    \begin{enumerate}
    \item verifies challenge response
    \item fetches the public key for QURI (using SSL)
    \item randomly generates a one-way relationship id (REQUESTED-RELID)
    \item randomly generates a one-way request id (REQUESTED-REQID)
    \item encrypts REQUESTED-RELID to requestor and signs it
    \item makes message available to be fetched using REQUESTED-REQID to identify it
    \item redirects the requestor's browser home to QURI, where the return-relid 
        function is called with SURI and REQUESTED-REQID as arguments
    \end{enumerate}

\item Requestor's server processes the return-relid call:
    \begin{enumerate}
    \item verifies browser is logged in as the owner of QURI
    \item fetches public key for SURI (using SSL)
    \item fetches encrypted REQUESTED-RELID from SURI using REQUESTED-REQID
    \item decrypts and verifies REQUESTED-RELID
    \item randomly generates RETURNED-RELID
    \item randomly generates RETURNED-REQID
    \item encrypts "REQUESTED-RELID RETURNED-RELID" to friendee and signs it
    \item makes message available to be fetched using RETURNED-REQID to identify it
    \item redirects the friender back to SURI, where the friend-final function is called
    with QURI and RETURNED-REQID as arguments.
    \end{enumerate}

\item Responder's processes the friend-final call:
    \begin{enumerate}
    \item fetches encrypted RETURNED-RELID from QURI using RETURNED-REQID
    \item decrypts and verifies message, must contain correct REQUESTED-RELID
    \item stores request for friendee to accept/deny
    \end{enumerate}
\end{enumerate}

There are five commands related to friendship request. The first three are the
commands used by the user agent on behalf of the browser for the three major
steps. The last two are commands used by DSNPd to fetch the encrypted the
relids.

\subsubsection{Relid Request}

The relid request is issued by the responder's server on behalf of the
requestor. The server generates a relationship ID and makes it available for
the requestor's server to fetch. It then redirects the user back home where the
request can be processed.

\vspace{10pt}
\begin{verbatim}
    RELID_REQUEST user identity EOL

    returns: OK reqid EOL
    context: local connection
\end{verbatim}
\vspace{10pt}

\subsubsection{Relid Response}

The relid response is executed by the requestor. The requestor must be logged
in for this command to run. The requestor's server fetches the request from the
responder's server, decrypts and verifies it. It then generates a response and
makes it available for the responder's server to fetch in the final step.

\vspace{10pt}
\begin{verbatim}
    RELID_RESPONSE login_token reqid identity EOL

    returns: OK reqid EOL
    context: local connection
\end{verbatim}
\vspace{10pt}

\subsubsection{Friend Final}

The final step in the friend request protocol is for the responder's server to
verify the response, which includes a copy of the request it generated in the
first step. If the response validates, a friend request is stored for the
responder user to accept or deny.

\vspace{10pt}
\begin{verbatim}
    FRIEND_FINAL user reqid identity EOL

    returns: OK EOL
    context: local connection
\end{verbatim}
\vspace{10pt}

\subsubsection{Fetch Requested Relid}

\vspace{10pt}
\begin{verbatim}
    FETCH_REQUESTED_RELID reqid EOL

    returns: OK message EOL
    context: TLS connection
\end{verbatim}
\vspace{10pt}

\subsubsection{Fetch Response Relid}

\vspace{10pt}
\begin{verbatim}
    FETCH_RESPONSE_RELID reqid EOL

    returns: OK message EOL
    context: TLS connection
\end{verbatim}

\subsection{Friendship Accept and Deny}

The next time the friendee logs in they are presented with the friendship
request. They can either accept or deny the request. 

The acceptor sends accept notification with both relids. They are sent back
indicating that the friendship was registered on the other end. The acceptor
then registers the friendship and sends a registered message. It can can now
send broadcast key and broadcast tree insertion messages. The other end can
send these messages after it receives the registered message.

\subsubsection{Accept Friend}

Accept friend is issued by the responder. The particular friend request is
identified by reqid, which is the request ID originally allocated by the
responder in the relid request command. The responder must be logged in.

\vspace{10pt}
\begin{verbatim}
    ACCEPT_FRIEND login_token reqid EOL

    returns: OK EOL
    context: local connection
\end{verbatim}
\vspace{10pt}

\subsubsection{Prefriend Message}

\vspace{10pt}
\begin{verbatim}
    PREFRIEND_MESSAGE relid length EOL message EOL

    returns: message dependent (see below).
    context: TLS connection
\end{verbatim}
\vspace{10pt}

During the friend accept exchange, these messages arrive as the payload to
prefriend messages. Notify accept is used to indicate to the requestor that the
reciever intends to accept the friendship request. If the requestor still
considers the request valid, it indicates so and registers the friendship. The
friendee then registers the friendship and sends the REGISTERED message to
indicate that the process is now complete, and friend-friend messages can be
sent. This is how the friender knows it is safe to begin sending messages and
otherwise broadcast information.

\subsubsection{Notify Accept}

\vspace{10pt}
\begin{verbatim}
    NOTIFY_ACCEPT requested_relid returned_relid EOL

    returns: OK EOL
    context: prefriend message
\end{verbatim}
\vspace{10pt}

\subsubsection{Registered}

\vspace{10pt}
\begin{verbatim}
    REGISTERED requested_relid returned_relid EOL

    returns: OK EOL
    context: prefriend message
\end{verbatim}

\subsection{Login as a Friend}

Once a user is logged in to her page, she is able to login to her friend's
pages without submitting any credentials. The friend's site requests that she
go to her own page to fetch the answer to a crypto challenge that is posed
directly to her identity. At her own site it is verified that she is is the
owner, and the login token is returned to the friend's site. Note that this
pattern is identical to friendship request, and is repeated throughout DSNP.

The user wishing to login to the friend's site is referred to as the requestor,
and she is identified as QURI. The relid she uses to identify the relationship
we call the QURI-RELID, and will be the one she was given during the friendship
request process. The friend who's page is being logged into will be called the
responder, and her identity is SURI.

\begin{enumerate}
\item The requestor visits SURI/login-as-friend
    \begin{enumerate}
    \item submits as the only argument a hash of QURI
    \end{enumerate}

\item The responder's server processes the request
    \begin{enumerate}
    \item verifies that hash(QURI) is a friend
    \item randomly generates a REQID and login token
    \item encrypts the token to the user and signs it
    \item makes it available to be fetched with REQID as identifier
    \item redirects user to QURI/return-token with hash(QURI) and REQID as
            arguments
    \end{enumerate}

\item The requestor's server verifies the browser is the identity owner
    \begin{enumerate}
    \item checks that hash(SURI) is a friend
    \item if browser is not logged in, fails the process
            (sending the user to a login page encourages phishing)
    \item fetches the token using from SURI using REQID to identify it
    \item decrypts and verifies the token
    \item redirects the browser to SURI/submit-ftoken with QURI and the TOKEN
            as aguments
    \end{enumerate}

\item Friend login final
    \begin{enumerate}
    \item verifies that TOKEN is valid for QURI.
    \item grants friend credentials to the browser for the session.
    \end{enumerate}
\end{enumerate}

There are four commands related to friend login. The first three are used by
the user-agent on behalf of the user in the primary challenge-response scheme.
The fourth is used by the friend logging in to fetch the encrypted challenge.

\subsubsection{Ftoken Request}

\vspace{10pt}
\begin{verbatim}
    FTOKEN_REQUEST user hash EOL 

    returns: OK identity hash reqid EOL
    context: local connection
\end{verbatim}
\vspace{10pt}

\subsubsection{Ftoken Response}

The Ftoken Response command is executed by the requestor's user agent. It is
reponsible for supplying the proof that the browser owns the identity that is
logging it. This command requires users be logged in.

\vspace{10pt}
\begin{verbatim}
    FTOKEN_RESPONSE login_token hash reqid EOL 

    returns: OK identity token EOL
    context: local connection
\end{verbatim}
\vspace{10pt}

\subsubsection{Submit Ftoken}

The session ID is a string that the user agent submits to identify the browser
session that the login is for. This session id may be used later by DSNPd to
invalidate the login.

\vspace{10pt}
\begin{verbatim}
    SUBMIT_FTOKEN token session_id EOL 

    returns: OK identity hash lasts EOL
    context: local connection
\end{verbatim}
\vspace{10pt}

\subsubsection{Fetch Ftoken}

\vspace{10pt}
\begin{verbatim}
    FETCH_FTOKEN reqid EOL

    returns: OK message EOL
    context: TLS connection
\end{verbatim}

\subsection{Messages to Friends}

Sending friend-friend messages that are encrypted to the recipient and signed
by the sender. 

\subsubsection{Submit Message}

\vspace{10pt}
\begin{verbatim}
    SUBMIT_MESSAGE login_token identity length EOL

    returns: OK EOL
    context: local connection
\end{verbatim}
\vspace{10pt}

\subsubsection{Message}

\vspace{10pt}
\begin{verbatim}
    MESSAGE relid length EOL message EOL

    returns: message dependent (see below)
    context: TLS connection
\end{verbatim}

\subsection{Broadcasting to a Group}

As previously mentioned, DSNP uses a broadcast key for the sending of messages
to groups. The key has an ID and a generation. The ID is a base64 encoded
random string assigned by the owner and used by the recipients to identify the
group within the sender's collection of groups.

\subsubsection{Submit Broadcast}

\vspace{10pt}
\begin{verbatim}
    SUBMIT_BROADCAST login_token length EOL message EOL

    returns: OK EOL
    context: local connection
\end{verbatim}
\vspace{10pt}

\subsubsection{Broadcast Key}

\vspace{10pt}
\begin{verbatim}
    BROADCAST_KEY dist_name generation key EOL

    returns: OK EOL
    context: TLS connection
\end{verbatim}
\vspace{10pt}

\subsubsection{Broadcast Recipient}

\vspace{10pt}
\begin{verbatim}
    BROADCAST_RECIPIENT relid EOL

    returns: OK EOL
    context: TLS connection
\end{verbatim}
\vspace{10pt}

\subsubsection{Broadcast}

\vspace{10pt}
\begin{verbatim}
    BROADCAST network generation length EOL message EOL

    returns: message dependent
    context: TLS connection
\end{verbatim}
\vspace{10pt}

\subsubsection{Direct Broadcast}

\vspace{10pt}
\begin{verbatim}
    DIRECT_BROADCAST seq_num date length EOL message EOL

    returns: OK EOL
    context: broadcasted message
\end{verbatim}

\subsection{Remote Broadcasting}

Remote broadcasting (or remote publishing) covers activity that a user makes on
a friend's site, such as commenting on a photo or, writing a public message on
a user's message board. This activity has to be authorized by both the author
of the message and the subject. It must be encrypted and signed by both parties
to prove to the message was not forged, and to ensure that only common friends
are able to view such messages. The encryption requirement may be relaxed to
allow others outside of the common friend group to view messages.

\subsubsection{Remote Broadcast Request}

\vspace{10pt}
\begin{verbatim}
    REMOTE_BROADCAST_REQUEST flogin_token length EOL message EOL

    returns: OK reqid EOL
    context: local connection
\end{verbatim}
\vspace{10pt}

\subsubsection{Remote Broadcast Response}

\vspace{10pt}
\begin{verbatim}
    REMOTE_BROADCAST_RESPONSE login_token reqid EOL 

    returns: OK reqid EOL
    context: TLS connection
\end{verbatim}
\vspace{10pt}

\subsubsection{Remote Broadcast Final}

\vspace{10pt}
\begin{verbatim}
    REMOTE_BROADCAST_FINAL flogin_token reqid EOL 

    returns: OK EOL
    context: local conection
\end{verbatim}
\vspace{10pt}

\subsubsection{Encrypt Remote Broadcast}

\vspace{10pt}
\begin{verbatim}
    ENCRYPT_REMOTE_BROADCAST flogin_token seq_num length EOL message EOL

    returns: OK reqid EOL
    context: TLS connection
\end{verbatim}
\vspace{10pt}

\subsubsection{Return Remote Broadcast}

\vspace{10pt}
\begin{verbatim}
    RETURN_REMOTE_BROADCAST reqid dist_name generation length EOL message EOL

    returns OK reqid EOL
    context: TLS connection
\end{verbatim}
\vspace{10pt}

\subsubsection{Remote Broadcast}

\vspace{10pt}
\begin{verbatim}
    REMOTE_BROADCAST hash dist_name generation seq_num length EOL message EOL

    returns: message dependent (see below)
    context: broadcasted message
\end{verbatim}
\vspace{10pt}

\subsubsection{Remote Inner}

\vspace{10pt}
\begin{verbatim}
    REMOTE_INNER seq_num date length EOL

    returns: OK EOL
    context: remote broadcast message
\end{verbatim}

\section{Notifications}

The DSNP daemon defers to the user-agent software for tasks that are not
associated with identity, authentication, authorization, encryption, etc. This
includes content that arrives from friends, and various notifications that
result in user experience. Various components require syncronization.

\subsection{Notification Broadcast}

\vspace{10pt}
\begin{verbatim}
    NOTIFICATION_BROADCAST user author seq_num date time length 
\end{verbatim}
\vspace{10pt}

\subsection{Notification Message}

\vspace{10pt}
\begin{verbatim}
    NOTIFICATION_MESSAGE user author date time length 
\end{verbatim}
\vspace{10pt}

\subsection{Notification Remote Message}

\vspace{10pt}
\begin{verbatim}
    NOTIFICATION_REMOTE_MESSAGE user subject author seq_num date time length 
\end{verbatim}
\vspace{10pt}

\subsection{Notification Remote Publication}

\vspace{10pt}
\begin{verbatim}
    NOTIFICATION_REMOTE_PUBLICATION user subject length 
\end{verbatim}
\vspace{10pt}

\subsection{Notification Logout}

The logout notification is used by the daemon to indicate to the user agent
that a login session is no longer valid. This should invalidate any cookies
that have been handed out to user. The session ID can be any string of
characters that the user agent wishes to use. It is limited to 48 characters.

\vspace{10pt}
\begin{verbatim}
    NOTIFICATION_LOGOUT session_id
\end{verbatim}
\vspace{10pt}

\subsection{Notification New User}

Indicates that user creation succeeded. The user agent should register the user
in its database.

\vspace{10pt}
\begin{verbatim}
    NOTIFICATION_NEW_USER user
\end{verbatim}
\vspace{10pt}

\subsection{Friend Request Sent}

\vspace{10pt}
\begin{verbatim}
    FRIEND_REQUEST_SENT user iduri hash reqid requested_relid response_relid 
\end{verbatim}
\vspace{10pt}

\subsection{Friend Request Received}

\vspace{10pt}
\begin{verbatim}
    FRIEND_REQUEST_RECEIVED user iduri hash reqid requested_relid response_relid 
\end{verbatim}
\vspace{10pt}

\end{document}

