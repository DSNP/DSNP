%
%   Copyright 2011 Adrian Thurston <thurston@complang.org>
%

% vim:expandtab:

\documentclass[letterpaper,11pt,oneside]{article}
\usepackage{comment}

\topmargin -0.20in
\oddsidemargin 0in
\textwidth 6.5in
\textheight 9in

\setlength{\parskip}{0pt}
\setlength{\topsep}{0pt}
\setlength{\partopsep}{0pt}
\setlength{\itemsep}{0pt}

\begin{document}

%
% Title page
%

\thispagestyle{empty}
\begin{center}
{\huge DSNP: Distributed Social Networking Protocol}\\
\vspace*{12pt}
{\Large Protocol Specification}\\
\vspace{12pt}
by\\
\vspace{12pt}
{\large Dr. Adrian D. Thurston}\\
\vspace{22pt}
{\noindent\bf\large Protocol Version: 0.4}\\
\vspace{6pt}
{\noindent\bf\large Document Revision: 8}\\
\vspace{6pt}
{\noindent\bf\large Date: February 23, 2011}
\end{center}

\pagenumbering{roman}

\vspace{1.3in}

\section*{License}

Copyright \copyright\ 2007-2011 Dr. Adrian D. Thurston

\vspace{5pt}

{\bf\it\noindent Permission to use, copy, modify, and/or distribute this
software for any purpose with or without fee is hereby granted, provided that
the above copyright notice and this permission notice appear in all copies.}

\vspace{5pt}

{\bf\it\noindent
THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.}

\vspace{1.5in}

{\noindent\bf\large DISCLAIMER: This document is draft quality. It is steadily
improving in lockstep with the reference implementation, Choice Social.}

\newpage

\tableofcontents

\pagenumbering{arabic}

\section{Introduction}

DSNP is a protocol for distributed social networking. DSNP allows you to host
your profile with a provider of your choice, or host your profile yourself,
without the choice impacting who you are able to invite as connections.
Communication between you and the people you trust is private and safe from
forgery. The updates and notes we share are artifacts of our lives. No single
provider should host such information for everyone. 

\subsection{Properties of DSNP}

\begin{enumerate}

\item Identities are URI-based.

\item The system is distributed at the level of identities, as opposed to
collections of identities. Authentication and authorization mechanisms are
based on the credentials of the two users who are interacting. DSNP does not
rely on simply securing the server-server communications with SSL.

\item There is a single sign-on. Once a user has signed into her profile, she
is able to get access to her friend's profiles without submitting any password.

\item DSNP is secure against forgery by non-friends and friends. It is secure
against eavesdropping by non-friends.

\item DSNP allows friendship claims and user activity to be verified by trusted
third parties. False friendships and statements can be claimed easily, but they
can also be discredited easily. This makes it safe for you to evaluate new
friends you don't yet fully trust, without worrying that person will forge
statements by you.

\item Security does not rely on DNS or SSL. If ownership of a domain is lost to
an attacker who is able to secure an SSL cert for the domain, the attacker does
not gain control of the identities on the domain.

\item DSNP allows unfriending. Once a user is unfriended, they no longer have
access to the user's broadcasts, even if they are somehow able to snoop the
broadcast traffic.

\end{enumerate}

\subsection{Security Model}

DSNP leverages RSA public key cryptography for identity, the sharing of secrets
and the declaration of relationships. It can be described as a public-key
cryptosystem for web-based identities. Each identity gets a public/private key
pair. The public portion of the key must be fetched over SSL. By requiring SSL
for public key fetches we give some assurance that the correct public key is
always distributed, without introducing the complexities involved with a
web-of-trust, or the cost of commercial certificates on a per-user basis. It is
a trade off, however, as it is possible for a domain to change hands and for
the new owner to start different certs for the identities inside the domain.

Use of SSL makes sense because it is already needed to protect the HTTP
interface to the system. We simply use the same cert to solve the problem of
securely transmitting public keys.

Since public keys are securely exchanged, direct communication between friends
can be protected in the usual asymmetric manner, where a session key is
encrypted using the peer's public key, then content is encrypted using the
session key.

Since users can be expected to have very large friend lists, it is desirable to
omit the use of SSL when delivering messages. DNSP could permit this, without
explicitly identifying the sender or recipient. Only pre-shared relationship
identifiers are transmitted. This identifier has meaning only to the sender and
recipient. A snooper is able to discover that pairs are repeatedly
communicating, but cannot discover who. This is in contrast with schemes such
as PGP or CMS, where senders and recipients are identified in each
communication.

Messages broadcasted to all friends are handled using a pre-shared broadcast
key. This is akin to a long-running session key just for broadcasts. Using a
pre-shared key means that messages do not need to crafted for each recipient.
The message can be computed by the sender, stored once, then a copy sent to
each recipient. If desired, messages can be handed to a third party and
delivered on behalf of the user, without the third party being privy to the
message. Only the sender/recipient domains and the relationship identifiers
(which are chosen randomly) are revealed to the broker. 

When you send messages to your friends, either directly or by broadcast,
messages are signed with your private key. Your contacts can then use your
public key to verify that you wrote the message, uploaded the photo, commented
on someone else's post, etc. Message signatures can also be given to common
friends for verification. This solves the problem of forgery, which is of
practical concern for individuals with reputations to preserve among their peer
groups, especially as peer groups grow. Of course, one loses deniability when
messages are signed, but if deniability is needed, social networking is
probably the wrong communication medium.

Your list of friends can be treated as private information. It is impossible
for someone to probe your list of friends if you don't want to publish it. The
list must be explicitly granted, even to current friends (see next point for a
minor exception). This makes it possible to partition your relationships into
different groups, such as family, close friends, co-workers, and people you
hardly know but might like to get to know better.

\subsection{Definitions}

\begin{itemize}

\item User-agent: Software that a user, and user's connections interact with.
This software provides the 'front' for the user's identity. At a minimum, this
should be a web-based application, though other forms of user-agent are
possible.

\end{itemize}

\section{Basics}

In the sections that follow, standard regular expression syntax is used to
describe the terminal elements of the grammar. A less formal notation is used
for commands and other protocol elements that are constructed with the base
elements. In the less formal sections, white space simply used in places where
it is required.

All commands, messages, and encryption packets have the same general structure.
They consist of a command or message name, a list of arguments, CRLF, and an
optional message body. If there is a message body, the last argument will be
the number of bytes in the message body. Message bodies can be arbitrary data,
and should be parsed separately from the message. A CRLF follows the message
body.

\subsection{Modified Base64}

Throughout DSNP a modified Base64 encoding is used for binary data. The
characters \verb|-| and \verb|_| are used in place of \verb|+| and \verb|/| for
the 63rd and 64th characters. This modified encoding is commonly used in
applications where Base64 data must be embedded in URLs. Note that we omit
trailing padding, which is normally specified using the \verb|=| character.

\vspace{10pt}
\begin{verbatim}
    base64: /[A-Za-z0-9\-_]+/
\end{verbatim}
\vspace{10pt}

\subsection{User Names}

Valid characters in user names include letters, numbers, dot, dash and
underscore. Uppercase letters can be used to specify, but they are stored and
displayed in all lowercase to ensure that URIs are given as lowercase.

\vspace{10pt}
\begin{verbatim}
    user: /[a-zA-Z0-9][a-zA-Z0-9\.\-_]*/
\end{verbatim}
\vspace{10pt}

\subsection{Passwords}

Passwords can be any comprised any graphical characters.

\vspace{10pt}
\begin{verbatim}
    pass: [::graph::]+
\end{verbatim}
\vspace{10pt}

\subsection{Timeouts}

A DSNP implementation should close connections after a time of inactivity. The
DSNP daemon times out connections after 7 seconds, both when reading and
writing. The user agent times out connections to the daemon after 12 seconds.

\section{Encryption Parameters and Data}

There are ten messages for carrying encryption parameters and encrypted data.
These messages most often carry binary payloads. They are often encrypted and
used in the construction of other packets. Due to these circumstances, and the
fact that they are constructed and parsed only within the confines of DSNPd, it
makes sense to construct them in binary form. As a general rule, encryption
packets do not carry any sender or recipient information. Senders and
recipients are transmitted in the container message.

The basic element of the encryption packet is the binary string. It is composed
of a 16bit length in network byte order, then the binary data. Many of the
packet components are expected to contain other packets. The length-data idiom
still applies here. The data can be treated as an opaque binary string that is
then reparsed as some other packet.

\vspace{10pt}
\begin{verbatim}
    len16   -> octet octet
    bin16   -> len16 octet*
\end{verbatim}
\vspace{10pt}

\subsection{Public Key}
\label{public-key-packet}

The public-key packet is used for transmitting a user's public key. The key
contains \verb|n| and \verb|e| BIGNUM components, encoded in big-endian binary
format. 

\vspace{10pt}
\begin{verbatim}
    n           -> bin16
    e           -> bin16
    public_key  -> 0x01 n e
\end{verbatim}
\vspace{10pt}

\subsection{Public Key Set}
\label{public-key-set}

The Public Key Set packages up the four public keys at privilege levels 0 to 3.
Privilege level 0 is the most trusted. The public key set is delivered in a
signed packet (Section \ref{signed}), with the signature verifiable by the
privilege 0 key.

\vspace{10pt}
\begin{verbatim}
    priv0           -> bin16
    priv1           -> bin16
    priv2           -> bin16
    priv3           -> bin16
    public_key_set  -> 0x02 priv0 priv1 priv2 priv3
\end{verbatim}
\vspace{10pt}

\subsection{Relid Set}

The Relid Set is used to package up a collection of relationship IDs that are
used to identify one direction of a relationship. The four relids correspond to
the four privilege levels. All four relids identify the same relationship. A
user messages another user at a specific privilege level by choosing the
appropriate relid corresponding to the protection desired.

\vspace{10pt}
\begin{verbatim}
    priv0      -> bin16
    priv1      -> bin16
    priv2      -> bin16
    priv3      -> bin16
    relid_set  -> 0x03 priv0 priv1 priv2 priv3
\end{verbatim}
\vspace{10pt}

\subsection{Relid Set Pair}

The Relid Set Pair packages up two sets of relationship IDs. This packet is
used in the friendship request process. It is useful for storage of the
relationship IDs. Also, it is returned by the requestor and serves two
purposes, to answer to the encryption challenge, and to return the friendship
requestor's relationship IDs.

\vspace{10pt}
\begin{verbatim}
    requested       -> len16 relid_set
    returned        -> len16 relid_set
    relid_set_pair  -> 0x04 requested returned
\end{verbatim}
\vspace{10pt}

\subsection{Relid Response}

The relid response is the packet that the friendship requestor returns to the
responder. It contains a request ID and the pair of relid sets. The request ID
is used to identify the friendship request in the accept/deny process. The
relid set pair contains the set of relids generated by the responder and the
set returned by the requestor.

\vspace{10pt}
\begin{verbatim}
    peer_notify_reqid  -> bin16
    rr_relid_set_pair  -> len16 relid_set_pair
    relid_response     -> 0x05 peer_notify_reqid rr_relid_set_pair
\end{verbatim}
\vspace{10pt}

\subsection{Private Key}

Private keys are never transmitted, but they must be stored and backed up
(encrypted). This packet type specifies the format of the private key before it
is encapsulated in a protection envelope.

\vspace{10pt}
\begin{verbatim}
    n            -> bin16
    e            -> bin16
    d            -> bin16
    p            -> bin16
    q            -> bin16
    dmp1         -> bin16
    dmq1         -> bin16
    iqmp         -> bin16
    private_key  -> 0x06 n e d p q dmp1 dmq1 iqmp
\end{verbatim}
\vspace{10pt}

\subsection{PW Encrypted}

This packet contains data encrypted with the owning user's password. The
password is hashed (SHA1) and used as the RC4 key (note RC4 is temporary).

\vspace{10pt}
\begin{verbatim}
    pw_enc_message  -> len16 SYM_ENC( plain_message ) 
    pw_encrypted -> 0x07 pw_enc_message
\end{verbatim}
\vspace{10pt}

\subsection{Signed}
\label{signed-packet}

This packet contains plaintext data that is accompanied by a signature. Unless
specified otherwise, the signature is acquired by applying RSA-sign to the
plaintext. 

In the BK Signed Encrypted and the Signed Encrypted messages the
signature is acquired by concatenating either the broadcast key or the
recipient's public key with the plaintext then applying RSA-sign to that. The
plain message component excludes the keys.

\vspace{10pt}
\begin{verbatim}
    sig            -> bin16
    plain_message  -> bin16
    signed         -> 0x08 sig plain_message
\end{verbatim}
\vspace{10pt}

\subsection{BK Signed Encrypted}

The bk-signed-encrypted message contains data that is signed with a public RSA
key and encrypted with a pre-shared symmetric key. The encrypted data block
contains two components: the signature and the message data. Both are encrypted
as a single stream. The signature is produced by concatenating the broadcast
key with the message data, then signing the resulting block. SHA1 is used as
the signing hash. RC4 is used as the stream cipher (temporary).

\vspace{10pt}
\begin{verbatim}
    enc_message          -> len16 SYM_ENC( signed ) 
    bk_signed_encrypted  -> 0x09 enc_message
\end{verbatim}
\vspace{10pt}

\subsection{Signed Encrypted}

The signed-encrypted message contains data that is signed with a public RSA
key, and encrypted with a symmetric key that is included in the message and
protected by the RSA public key. It has two components: the RSA-protected key,
and the symmetric-key protected RSA signature and message. The RSA sig and the
message body are encrypted using the symmetric key as a single stream. The
signature is produced by concatenating the public key packet (Section
\ref{public-key-packet} and the message body, then RSA-signing the resulting
block. SHA1 is used as the signing hash. RC4 is used as the stream cipher
(temporary).

\vspace{10pt}
\begin{verbatim}
    protected_key     -> len16 PK_ENC( sym_key )
    enc_message       -> len16 SYM_ENC( signed )
    signed_encrypted  -> 0x0a protected_key enc_message
\end{verbatim}
\vspace{10pt}

%
% Section: Protocol
%

\section{Protocol}

\subsection{Common Elements}

\vspace{10pt}
\begin{verbatim}
    dist_name = base64;

    path_part = ( graph - '/' )+;

    identity = 
        ( 'https://' path_part '/' ( path_part '/' )* );

    site = identity;

    number = [0-9]+           


    version = '0.1'
    supported_versions =  version ( '|' version )*;
    key = base64;

    EOL = '\r'? '\n';
\end{verbatim}

\subsection{Connection Negotiation}

The DSNP command is the initial command that must be sent by all clients. In
this command, the client sends the DSNP versions it is willing to talk, the
site it wishes to communicate with, and the connection authorization method.

The auth method can be either a local connection, or a TLS-secured connection.
Local connections require a secret key, which is typically stored on disk on
the server. Local connections must pass through the loopback network interface
(be bound to 127.0.0.1). Local connections that do not should be rejected.

If it is a TLS-secured connection, the server must supply a valid certificate
that matches the hostname of the site. The server responds with OK followed by
the version it has chosen from the list. This should be the highest supplied
version it supports.

\vspace{10pt}
\begin{verbatim}
    auth: /local/ key
    auth: /start_tls/

    DSNP supported_versions site auth EOL

    returns: OK version EOL
    context: TCP
\end{verbatim}

\subsection{Creating Users}

A user name and password is requested. The user's IDURI is assigned. It
consists of the scheme \verb'dsnp://', the site's root name, and the user name
as the final path component. It must end with a slash. Similarly, the user's
IDURL is assigned. This is identical, except the scheme is \verb'https://'.

%
% IDURI: dsnp://www.foo.com/site/gia/ 
% IDURL: https://www.foo.com/site/gia/
%

Four RSA key pairs are created. The keys have privilege levels 3 to 0.
Privilege level 3 is considered the weakest. Privilege level 0 is reserved for
the most significant actions, such as profile moving.

\begin{itemize}
\item Priv 3: Not password protected. For activity that doesn't require the user be logged
in.

\item Priv 2: Password protected, decrypted in memory only while user is logged
in. A sig indicates the user is currently logged in. Used for activity by
logged in user.

\item Priv 1: Password protected. Purged from memory immediately after it is
used. Decrypted on each login. A signed timestamp by this key indicates the
user logged in with her password at that time.

\item Priv 0: Password protected. Purged from memory immediately after use.
Decrypted on demand. A message signed by this key indicates the user submitted
her password to produce the signature. This privilege ring is reserved for
moving and deleting the identity.
\end{itemize}

The public portions of the keys are made available (Section
\ref{public-key-command}). The key must always be fetched using SSL. This
guarantees that a key has been provided by the server hosting the identity and
has not been altered.

\subsubsection{New User}

\vspace{10pt}
\begin{verbatim}
    NEW_USER user pass EOL

    returns: OK EOL
    context: local connection
\end{verbatim}

\subsection{Owner Login}

To login, the user agent submits credentials to the LOGIN command. key that
will be used to verify with the server that the user is logged in when commands
are issued (not yet added to the protocol).

\subsubsection{Login}

The session ID is a string that is used to associate the granted login token
with the session ID of the browser. It is supplied to the user agent when DSNPd
needs to specify to the user agent that the browser's login token has expired.

\vspace{10pt}
\begin{verbatim}
    LOGIN user pass session_id EOL

    returns: OK hash token lasts EOL
    context: TLS connection
\end{verbatim}
\vspace{10pt}

On success, the login commands returns the owner's URI hash, a login token, and
the number of seconds the token is valid for. The URI hash can be computed
independently, but is returned here for convenience.

Note that as of version 0.2 of DSNP, the token is not yet made use of. It
should be!

\subsubsection{Public Key}
\label{public-key-command}

The Public Key command is for fetching a user's public key. A public key must
never change. If a peer detects a change, the user must be considered invalid.
The message returned is a signed packet (Section \ref{signed-packet}), that
contains a public key set (Section \ref{public-key-set}). The priv0 key is used
for signing.

\vspace{10pt}
\begin{verbatim}
    PUBLIC_KEY user EOL

    returns: OK message EOL
    context: TLS connection
\end{verbatim}


\subsection{Friendship Request}

The friendship request has two purposes. The primary purpose is the stated, for
a remote user to indicate to a local user that she wishes to establish a
connection. The secondary purpose is to securely exchange random identifiers
that will be used by the two parties to identify the relationship, should it
proceed.

It is important that the user who is receiving the friend request be assured
that the person controlling the browser is the actual owner of the identity
submitted. To guarantee this, we must send the browser home, where it can
answer to a challenge to decrypt a randomly selected token, then send the token
back. When the token is sent back a similar challenge is issued to ensure the
person making the friend request indeed has the right identity.

There are two other parts of the DSNP protocol that have this flavour:
cross-site login and remote publishing. Indeed it is a recurring pattern to
send the browser home so the that all three parties (browser, the browser's
server and the friend's server) are assured they are dealing with who they
think they are.

The person requesting friendship is the referred to as the requestor, with
identity QURI. The person who is receiving the request is the responder, with
identity SURI

\begin{enumerate}
\item The requestor fills in a friend request form at SURI
    \begin{enumerate}
    \item requestor answers a challenge, which can be a CAPTCHA, or 
            personalized question
    \item requestor submits QURI
    \end{enumerate}

\item Responder's server processes the request:
    \begin{enumerate}
    \item verifies challenge response
    \item fetches the public key for QURI (using SSL)
    \item randomly generates a one-way relationship id (REQUESTED-RELID)
    \item randomly generates a one-way request id (REQUESTED-REQID)
    \item encrypts REQUESTED-RELID to requestor and signs it
    \item makes message available to be fetched using REQUESTED-REQID to identify it
    \item redirects the requestor's browser home to QURI, where the return-relid 
        function is called with SURI and REQUESTED-REQID as arguments
    \end{enumerate}

\item Requestor's server processes the return-relid call:
    \begin{enumerate}
    \item verifies browser is logged in as the owner of QURI
    \item fetches public key for SURI (using SSL)
    \item fetches encrypted REQUESTED-RELID from SURI using REQUESTED-REQID
    \item decrypts and verifies REQUESTED-RELID
    \item randomly generates RETURNED-RELID
    \item randomly generates RETURNED-REQID
    \item encrypts "REQUESTED-RELID RETURNED-RELID" to friendee and signs it
    \item makes message available to be fetched using RETURNED-REQID to identify it
    \item redirects the friender back to SURI, where the friend-final function is called
    with QURI and RETURNED-REQID as arguments.
    \end{enumerate}

\item Responder's processes the friend-final call:
    \begin{enumerate}
    \item fetches encrypted RETURNED-RELID from QURI using RETURNED-REQID
    \item decrypts and verifies message, must contain correct REQUESTED-RELID
    \item stores request for friendee to accept/deny
    \end{enumerate}
\end{enumerate}

There are five commands related to friendship request. The first three are the
commands used by the user agent on behalf of the browser for the three major
steps. The last two are commands used by DSNPd to fetch the encrypted the
relids.

\subsubsection{Relid Request}

The relid request is issued by the responder's server on behalf of the
requestor. The server generates a relationship ID and makes it available for
the requestor's server to fetch. It then redirects the user back home where the
request can be processed.

\vspace{10pt}
\begin{verbatim}
    RELID_REQUEST user identity EOL

    returns: OK reqid EOL
    context: local connection
\end{verbatim}
\vspace{10pt}

\subsubsection{Relid Response}

The relid response is executed by the requestor. The requestor must be logged
in for this command to run. The requestor's server fetches the request from the
responder's server, decrypts and verifies it. It then generates a response and
makes it available for the responder's server to fetch in the final step.

\vspace{10pt}
\begin{verbatim}
    RELID_RESPONSE login_token reqid identity EOL

    returns: OK reqid EOL
    context: local connection
\end{verbatim}
\vspace{10pt}

\subsubsection{Friend Final}

The final step in the friend request protocol is for the responder's server to
verify the response, which includes a copy of the request it generated in the
first step. If the response validates, a friend request is stored for the
responder user to accept or deny.

\vspace{10pt}
\begin{verbatim}
    FRIEND_FINAL user reqid identity EOL

    returns: OK EOL
    context: local connection
\end{verbatim}
\vspace{10pt}

\subsubsection{Fetch Requested Relid}

\vspace{10pt}
\begin{verbatim}
    FETCH_REQUESTED_RELID reqid EOL

    returns: OK message EOL
    context: TLS connection
\end{verbatim}
\vspace{10pt}

\subsubsection{Fetch Response Relid}

\vspace{10pt}
\begin{verbatim}
    FETCH_RESPONSE_RELID reqid EOL

    returns: OK message EOL
    context: TLS connection
\end{verbatim}

\subsection{Friendship Accept and Deny}

The next time the friendee logs in they are presented with the friendship
request. They can either accept or deny the request. 

The acceptor sends accept notification with both relids. They are sent back
indicating that the friendship was registered on the other end. The acceptor
then registers the friendship and sends a registered message. It can can now
send broadcast key and broadcast tree insertion messages. The other end can
send these messages after it receives the registered message.

\subsubsection{Accept Friend}

Accept friend is issued by the responder. The particular friend request is
identified by reqid, which is the request ID originally allocated by the
responder in the relid request command. The responder must be logged in.

\vspace{10pt}
\begin{verbatim}
    ACCEPT_FRIEND login_token reqid EOL

    returns: OK EOL
    context: local connection
\end{verbatim}
\vspace{10pt}

\subsubsection{Notify Accept, Registered}

During the friend accept exchange, these messages arrive as the payload to
standard messages. They are identified as prefriend messages by the state of the
relationship. Notify accept is used to indicate to the requestor that the
receiver intends to accept the friendship request. If the requestor still
considers the request valid, it indicates so and registers the friendship. The
friendee then registers the friendship and sends the REGISTERED message to
indicate that the process is now complete, and friend-friend messages can be
sent. This is how the friender knows it is safe to begin sending messages and
otherwise broadcast information.

\vspace{10pt}
\begin{verbatim}
    NOTIFY_ACCEPT requested_relid returned_relid EOL

    returns: OK EOL
    context: prefriend message
\end{verbatim}
\vspace{10pt}

\vspace{10pt}
\begin{verbatim}
    REGISTERED requested_relid returned_relid EOL

    returns: OK EOL
    context: prefriend message
\end{verbatim}

\subsection{Login as a Friend}

Once a user is logged in to her page, she is able to login to her friend's
pages without submitting any credentials. The friend's site requests that she
go to her own page to fetch the answer to a crypto challenge that is posed
directly to her identity. At her own site it is verified that she is is the
owner, and the login token is returned to the friend's site. Note that this
pattern is identical to friendship request, and is repeated throughout DSNP.

The user wishing to login to the friend's site is referred to as the requestor,
and she is identified as QURI. The relid she uses to identify the relationship
we call the QURI-RELID, and will be the one she was given during the friendship
request process. The friend who's page is being logged into will be called the
responder, and her identity is SURI.

\begin{enumerate}
\item The requestor visits SURI/login-as-friend
    \begin{enumerate}
    \item submits as the only argument a hash of QURI
    \end{enumerate}

\item The responder's server processes the request
    \begin{enumerate}
    \item verifies that hash(QURI) is a friend
    \item randomly generates a REQID and login token
    \item encrypts the token to the user and signs it
    \item makes it available to be fetched with REQID as identifier
    \item redirects user to QURI/return-token with hash(QURI) and REQID as
            arguments
    \end{enumerate}

\item The requestor's server verifies the browser is the identity owner
    \begin{enumerate}
    \item checks that hash(SURI) is a friend
    \item if browser is not logged in, fails the process
            (sending the user to a login page encourages phishing)
    \item fetches the token using from SURI using REQID to identify it
    \item decrypts and verifies the token
    \item redirects the browser to SURI/submit-ftoken with QURI and the TOKEN
            as arguments
    \end{enumerate}

\item Friend login final
    \begin{enumerate}
    \item verifies that TOKEN is valid for QURI.
    \item grants friend credentials to the browser for the session.
    \end{enumerate}
\end{enumerate}

There are four commands related to friend login. The first three are used by
the user-agent on behalf of the user in the primary challenge-response scheme.
The fourth is used by the friend logging in to fetch the encrypted challenge.

\subsubsection{Ftoken Request}

\vspace{10pt}
\begin{verbatim}
    FTOKEN_REQUEST user hash EOL 

    returns: OK identity hash reqid EOL
    context: local connection
\end{verbatim}
\vspace{10pt}

\subsubsection{Ftoken Response}

The Ftoken Response command is executed by the requestor's user agent. It is
responsible for supplying the proof that the browser owns the identity that is
logging it. This command requires users be logged in.

\vspace{10pt}
\begin{verbatim}
    FTOKEN_RESPONSE login_token hash reqid EOL 

    returns: OK identity token EOL
    context: local connection
\end{verbatim}
\vspace{10pt}

\subsubsection{Submit Ftoken}

The session ID is a string that the user agent submits to identify the browser
session that the login is for. This session id may be used later by DSNPd to
invalidate the login.

\vspace{10pt}
\begin{verbatim}
    SUBMIT_FTOKEN token session_id EOL 

    returns: OK identity hash lasts EOL
    context: local connection
\end{verbatim}
\vspace{10pt}

\subsubsection{Fetch Ftoken}

\vspace{10pt}
\begin{verbatim}
    FETCH_FTOKEN reqid EOL

    returns: OK message EOL
    context: TLS connection
\end{verbatim}

\subsection{Messages to Friends}

Sending friend-friend messages that are encrypted to the recipient and signed
by the sender. 

\subsubsection{Submit Message}

\vspace{10pt}
\begin{verbatim}
    SUBMIT_MESSAGE login_token identity length EOL

    returns: OK EOL
    context: local connection
\end{verbatim}
\vspace{10pt}

\subsubsection{Message}

The message command is used to deliver prefriend messages and friend messages.
The type of message accepted is determined by the state of the friendship
request. The privilege level of the message is determined by the privilege
level relationship ID used to identify the message.

\vspace{10pt}
\begin{verbatim}
    MESSAGE relid length EOL message EOL

    returns: message dependent (see below)
    context: TLS connection
\end{verbatim}

\subsection{Broadcasting to a Group}

As previously mentioned, DSNP uses a broadcast key for the sending of messages
to groups. The key has an ID and a generation. The ID is a base64 encoded
random string assigned by the owner and used by the recipients to identify the
group within the sender's collection of groups.

\subsubsection{Submit Broadcast}

\vspace{10pt}
\begin{verbatim}
    SUBMIT_BROADCAST login_token length EOL message EOL

    returns: OK EOL
    context: local connection
\end{verbatim}
\vspace{10pt}

\subsubsection{Broadcast Key}

\vspace{10pt}
\begin{verbatim}
    BROADCAST_KEY dist_name generation key EOL

    returns: OK EOL
    context: TLS connection
\end{verbatim}
\vspace{10pt}

\subsubsection{Broadcast Recipient}

\vspace{10pt}
\begin{verbatim}
    BROADCAST_RECIPIENT relid EOL

    returns: OK EOL
    context: TLS connection
\end{verbatim}
\vspace{10pt}

\subsubsection{Broadcast}

\vspace{10pt}
\begin{verbatim}
    BROADCAST network generation length EOL message EOL

    returns: message dependent
    context: TLS connection
\end{verbatim}
\vspace{10pt}

\subsubsection{Direct Broadcast}

\vspace{10pt}
\begin{verbatim}
    DIRECT_BROADCAST length EOL message EOL

    returns: OK EOL
    context: broadcasted message
\end{verbatim}

\subsection{Remote Broadcasting}

Remote broadcasting (or remote publishing) covers activity that a user makes on
a friend's site, such as commenting on a photo or, writing a public message on
a user's message board. This activity has to be authorized by both the author
of the message and the subject. It must be encrypted and signed by both parties
to prove to the message was not forged, and to ensure that only common friends
are able to view such messages. The encryption requirement may be relaxed to
allow others outside of the common friend group to view messages.

\subsubsection{Remote Broadcast Request}

\vspace{10pt}
\begin{verbatim}
    REMOTE_BROADCAST_REQUEST flogin_token length EOL message EOL

    returns: OK reqid EOL
    context: local connection
\end{verbatim}
\vspace{10pt}

\subsubsection{Remote Broadcast Response}

\vspace{10pt}
\begin{verbatim}
    REMOTE_BROADCAST_RESPONSE login_token reqid EOL 

    returns: OK reqid EOL
    context: TLS connection
\end{verbatim}
\vspace{10pt}

\subsubsection{Remote Broadcast Final}

\vspace{10pt}
\begin{verbatim}
    REMOTE_BROADCAST_FINAL flogin_token reqid EOL 

    returns: OK EOL
    context: local connection
\end{verbatim}
\vspace{10pt}

\subsubsection{Encrypt Remote Broadcast}

\vspace{10pt}
\begin{verbatim}
    ENCRYPT_REMOTE_BROADCAST flogin_token length EOL message EOL

    returns: OK reqid EOL
    context: TLS connection
\end{verbatim}
\vspace{10pt}

\subsubsection{Return Remote Broadcast}

\vspace{10pt}
\begin{verbatim}
    RETURN_REMOTE_BROADCAST reqid dist_name generation length EOL message EOL

    returns OK reqid EOL
    context: TLS connection
\end{verbatim}
\vspace{10pt}

\subsubsection{Remote Broadcast}

\vspace{10pt}
\begin{verbatim}
    REMOTE_BROADCAST hash dist_name generation length EOL message EOL

    returns: message dependent (see below)
    context: broadcasted message
\end{verbatim}
\vspace{10pt}

\section{Notifications}

The DSNP daemon defers to the user-agent software for tasks that are not
associated with identity, authentication, authorization, encryption, etc. This
includes content that arrives from friends, and various notifications that
result in user experience. Various components require synchronization.

\subsection{Notification Broadcast}

\vspace{10pt}
\begin{verbatim}
    BROADCAST user publisher length 
\end{verbatim}
\vspace{10pt}

\subsection{Notification Message}

\vspace{10pt}
\begin{verbatim}
    MESSAGE user sender length 
\end{verbatim}
\vspace{10pt}

\subsection{Notification Remote Message}

\vspace{10pt}
\begin{verbatim}
    REMOTE_MESSAGE user publisher author time length 
\end{verbatim}
\vspace{10pt}

\subsection{Notification Remote Publication}

\vspace{10pt}
\begin{verbatim}
    REMOTE_PUBLICATION user publisher length 
\end{verbatim}
\vspace{10pt}

\subsection{Notification Logout}

The logout notification is used by the daemon to indicate to the user agent
that a login session is no longer valid. This should invalidate any cookies
that have been handed out to user. The session ID can be any string of
characters that the user agent wishes to use. It is limited to 48 characters.

\vspace{10pt}
\begin{verbatim}
    LOGOUT session_id
\end{verbatim}
\vspace{10pt}

\subsection{Notification New User}

Indicates that user creation succeeded. The user agent should register the user
in its database.

\vspace{10pt}
\begin{verbatim}
    NEW_USER user
\end{verbatim}
\vspace{10pt}

\subsection{Friend Request Received}

Notification for the responder to the friend request that a new request has
arrived.

\vspace{10pt}
\begin{verbatim}
    FRIEND_REQUEST_RECEIVED user iduri hash accept_reqid
\end{verbatim}
\vspace{10pt}

\subsection{Friend Request Sent}

Notification for the requestor of the relationship that a new request was
successfully sent.

\vspace{10pt}
\begin{verbatim}
    FRIEND_REQUEST_SENT user iduri hash user_notify_reqid
\end{verbatim}
\vspace{10pt}

\subsection{Friend Request Accepted}

Notification for the responder to the friend request that acceptance succeeded.

\vspace{10pt}
\begin{verbatim}
    FRIEND_REQUEST_ACCEPTED user iduri accept_reqid
\end{verbatim}
\vspace{10pt}

\subsection{Sent Friend Request Accepted}

Notification for the requestor of the relationship that the request was
accepted.

\vspace{10pt}
\begin{verbatim}
    SENT_FRIEND_REQUEST_ACCEPTED user iduri user_notify_reqid
\end{verbatim}
\vspace{10pt}

\section{User Messages}

User messages are submitted by the user agent to DSNPd, encrypted, distributed
over the network, decrypted, then handed to the receiving user agent for
storage and display. This particular section of DSNP is likely to change, as
better message formats become apparent. For the time being, we use an
rfc822-like message format. There are just four types.

\subsection{Broadcast}

Broadcast message type is used for so-called status updates.

\vspace{10pt}
\begin{verbatim}
Publisher-Iduri: publisher-iduri
Message-Id: message-id
Content-Type: text/plain
Type: broadcast
Date: YYYY-MM-DD HH:MM:SS

CONTENT
\end{verbatim}
\vspace{10pt}

\subsection{Board Post}

Board post is used for messages that are to be shared with the sender and
recipient's friends. The board post is akin to a "wall" message.

\vspace{10pt}
\begin{verbatim}
Author-Iduri: author-iduri
Publisher-Iduri: publisher-iduri
Message-Id: message-id
Type: board-post
Content-Type: text/plain
Date: YYYY-MM-DD HH:MM:SS

CONTENT
\end{verbatim}
\vspace{10pt}

\subsection{Name Change}

Name change is used to transmit a user's new name.

\vspace{10pt}
\begin{verbatim}
Publisher-Iduri: publisher-iduri
Message-Id: message-id
Type: name-change
Content-Type: text/plain
Date: YYYY-MM-DD HH:MM:SS

CONTENT
\end{verbatim}
\vspace{10pt}

\subsection{Photo Upload}

Photo upload is use to notifiy friend's about a photo that has been uploaded.
Resource-Id is an identifier describing the uploader's image.

\vspace{10pt}
\begin{verbatim}
Publisher-Iduri: publisher-iduri
Type: photo-upload
Message-Id: message-id
Type: name-change
Content-Type: image/jpg
Remote-Resource: /path/to/resource
Remote-Presentation: /path/to/presentation/page
Date: YYYY-MM-DD HH:MM:SS

CONTENT
\end{verbatim}
\vspace{10pt}

\end{document}
